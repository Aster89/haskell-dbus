% Copyright (C) 2009 John Millikin <jmillikin@gmail.com>
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

@ \section{Tests}

<<Tests.hs>>=
<<copyright>>
{-# LANGUAGE RankNTypes #-}
import Test.QuickCheck.Batch
import Test.QuickCheck

import Control.Monad (replicateM)
import Data.List (intercalate, isInfixOf)
import Data.Word (Word8, Word16, Word32, Word64)
import Data.Int (Int16, Int32, Int64)

import DBus.Types

options = TestOptions
	{ no_of_tests     = 100
	, length_of_tests = 1
	, debug_tests     = False
	}

main = do
	runTests "atoms" options . map run . concat $
		[<<atomic properties>>
		]
	
	{-
	runTests "variants" options . map run . concat $
		[<<variable properties>>
		]
	-}
	
	runTests "names" options . map run . concat $
		[<<name properties>>
		]

<<Tests.hs>>=
atomicProperties :: (Atomic a, Show a, Eq a, Arbitrary a) => Gen a -> [Property]
atomicProperties gen = let
	prop_Identity x = (fromAtom . toAtom) x == Just x
	prop_Equality x y = (x == y) == (toAtom x == toAtom y)
	prop_VariantTypeEquality x = atomType (toAtom x) ==
	                                 variantType (toVariant x)
	
	in variableProperties gen ++
	[ forAll gen prop_Identity
	, forAll gen prop_Equality
	, forAll gen prop_VariantTypeEquality
	]

<<atomic properties>>=
  atomicProperties (arbitrary :: Gen Bool)
, atomicProperties (arbitrary :: Gen Word8)
, atomicProperties (arbitrary :: Gen Word16)
, atomicProperties (arbitrary :: Gen Word32)
, atomicProperties (arbitrary :: Gen Word64)
, atomicProperties (arbitrary :: Gen Int16)
, atomicProperties (arbitrary :: Gen Int32)
, atomicProperties (arbitrary :: Gen Int64)
, atomicProperties (arbitrary :: Gen Double)
, atomicProperties (arbitrary :: Gen String)
, atomicProperties (arbitrary :: Gen ObjectPath)
, [ property prop_ObjectPathIdentity ]

, atomicProperties (arbitrary :: Gen Signature)
, [ property prop_SignatureIdentity
  , property prop_SignatureShowType
  ]

<<Tests.hs>>=
prop_ObjectPathIdentity x = (mkObjectPath . strObjectPath) x == Just x

prop_SignatureIdentity x = (mkSignature . strSignature) x == Just x
prop_SignatureShowType x = show (strSignature x) `isInfixOf` show x

<<Tests.hs>>=
variableProperties :: (Variable a, Show a, Eq a, Arbitrary a) => Gen a -> [Property]
variableProperties gen = let
	prop_Identity x = (fromVariant . toVariant) x == Just x
	prop_Equality x y = (x == y) == (toVariant x == toVariant y)
	in
	[ forAll gen prop_Identity
	, forAll gen prop_Equality
	]

<<variable properties>>=
--, variableProperties (arbitrary :: Gen Array)
--, variableProperties (arbitrary :: Gen Dictionary)
--, variableProperties (arbitrary :: Gen Structure)
--, variableProperties (arbitrary :: Gen Variant)

<<Tests.hs>>=
instance Arbitrary Char where
	coarbitrary = undefined
	arbitrary = choose ('!', '~') -- TODO: unicode?

iexp :: Integral a => a -> a -> a
iexp x y = floor $ fromIntegral x ** fromIntegral y

instance Arbitrary Word8 where
	coarbitrary = undefined
	arbitrary = fmap fromIntegral gen where
		gen = choose (0, max') :: Gen Integer
		max' = iexp 2 8 - 1

instance Arbitrary Word16 where
	coarbitrary = undefined
	arbitrary = fmap fromIntegral gen where
		gen = choose (0, max') :: Gen Integer
		max' = iexp 2 16 - 1

instance Arbitrary Word32 where
	coarbitrary = undefined
	arbitrary = fmap fromIntegral gen where
		gen = choose (0, max') :: Gen Integer
		max' = iexp 2 32 - 1

instance Arbitrary Word64 where
	coarbitrary = undefined
	arbitrary = fmap fromIntegral gen where
		gen = choose (0, max') :: Gen Integer
		max' = iexp 2 64 - 1

instance Arbitrary Int16 where
	coarbitrary = undefined
	arbitrary = fmap fromIntegral gen where
		gen = choose (0, max') :: Gen Integer
		max' = iexp 2 16 - 1

instance Arbitrary Int32 where
	coarbitrary = undefined
	arbitrary = fmap fromIntegral gen where
		gen = choose (0, max') :: Gen Integer
		max' = iexp 2 32 - 1

instance Arbitrary Int64 where
	coarbitrary = undefined
	arbitrary = fmap fromIntegral gen where
		gen = choose (0, max') :: Gen Integer
		max' = iexp 2 64 - 1

sized' :: Int -> Gen a -> Gen [a]
sized' atLeast g = sized $ \n -> do
	n' <- choose (atLeast, max atLeast n)
	replicateM n' g

clampedSize :: Arbitrary a => Int -> Gen String -> (String -> a) -> Gen a
clampedSize maxSize gen f = do
	s <- gen
	if length s > maxSize
		then sized $ \n -> resize (n `div` 2) arbitrary
		else return . f $ s

instance Arbitrary ObjectPath where
	coarbitrary = undefined
	arbitrary = fmap mkObjectPath' path' where
		c = ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_"
		path = fmap (intercalate "/" . ([] :)) genElements
		path' = frequency [(1, return "/"), (9, path)]
		genElements = sized' 1 (sized' 1 (elements c))

instance Arbitrary InterfaceName where
	coarbitrary = undefined
	arbitrary = clampedSize 255 genName mkInterfaceName' where
		c = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
		c' = c ++ ['0'..'9']
		
		genName = fmap (intercalate ".") genElements
		genElements = sized' 2 genElement
		genElement = do
			x <- elements c
			xs <- sized' 0 (elements c')
			return (x:xs)

instance Arbitrary BusName where
	coarbitrary = undefined
	arbitrary = clampedSize 255 (oneof [unique, wellKnown]) mkBusName' where
		c = ['a'..'z'] ++ ['A'..'Z'] ++ "_-"
		c' = c ++ ['0'..'9']
		
		unique = do
			elems' <- sized' 2 $ elems c'
			return $ ':' : intercalate "." elems'
		
		wellKnown = do
			elems' <- sized' 2 $ elems c
			return $ intercalate "." elems'
		
		elems start = do
			x <- elements start
			xs <- sized' 0 (elements c')
			return (x:xs)

instance Arbitrary MemberName where
	coarbitrary = undefined
	arbitrary = clampedSize 255 genName mkMemberName' where
		c = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
		c' = c ++ ['0'..'9']
		
		genName = do
			x <- elements c
			xs <- sized' 0 (elements c')
			return (x:xs)

instance Arbitrary ErrorName where
	coarbitrary = undefined
	arbitrary = fmap (mkErrorName' . strInterfaceName) arbitrary


prop_BusNameIdentity x = (mkBusName . strBusName) x == Just x
prop_InterfaceNameIdentity x = (mkInterfaceName . strInterfaceName) x == Just x
prop_ErrorNameIdentity x = (mkErrorName . strErrorName) x == Just x
prop_MemberNameIdentity x = (mkMemberName . strMemberName) x == Just x

<<name properties>>=
 atomicProperties (arbitrary :: Gen BusName)
, [ property prop_BusNameIdentity
  ]

, atomicProperties (arbitrary :: Gen InterfaceName)
, [ property prop_InterfaceNameIdentity
  ]

, atomicProperties (arbitrary :: Gen ErrorName)
, [ property prop_ErrorNameIdentity
  ]

, atomicProperties (arbitrary :: Gen MemberName)
, [ property prop_MemberNameIdentity
  ]

<<Tests.hs>>=
atomicType = elements
	[ DBusBoolean
	, DBusByte
	, DBusWord16
	, DBusWord32
	, DBusWord64
	, DBusInt16
	, DBusInt32
	, DBusInt64
	, DBusDouble
	, DBusString
	, DBusObjectPath
	, DBusSignature
	]

containerType = do
	c <- choose (0,3) :: Gen Int
	case c of
		0 -> fmap DBusArray arbitrary
		1 -> do
			kt <- atomicType
			vt <- arbitrary
			return $ DBusDictionary kt vt
		2 -> sized structType
		3 -> return DBusVariant

structType n | n >= 0 = fmap DBusStructure $ resize (n `div` 2) arbitrary

instance Arbitrary Type where
	coarbitrary = undefined
	arbitrary = oneof [atomicType, containerType]

instance Arbitrary Signature where
	coarbitrary = undefined
	arbitrary = clampedSize 255 genSig mkSignature' where
		genSig = fmap (concatMap typeCode) arbitrary

