:# Copyright (C) 2009-2011 John Millikin <jmillikin@gmail.com>
:# 
:# This program is free software: you can redistribute it and/or modify
:# it under the terms of the GNU General Public License as published by
:# the Free Software Foundation, either version 3 of the License, or
:# any later version.
:# 
:# This program is distributed in the hope that it will be useful,
:# but WITHOUT ANY WARRANTY; without even the implied warranty of
:# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
:# GNU General Public License for more details.
:# 
:# You should have received a copy of the GNU General Public License
:# along with this program.  If not, see <http://www.gnu.org/licenses/>.

\clearpage
\section{D-Bus clients}

:d DBus.Client
data Client = Client
	{ clientConnection :: Connection
	, clientCallbacks :: MVar (Map Serial Callback)
	, clientSignalHandlers :: MVar [Callback]
	, clientThreadID :: ThreadId
	}

type Callback = (ReceivedMessage -> IO ())
:

:d DBus.Client
attach :: Connection -> IO Client
attach connection = do
	callbacks <- newMVar Data.Map.empty
	signalHandlers <- newMVar []
	
	client <- mfix $ \client -> do
		threadID <- forkIO (mainLoop client)
		return (Client connection callbacks signalHandlers threadID)
	
	sendHello client
	return client
:

:d DBus.Client
detach :: Client -> IO ()
detach client = do
	killThread (clientThreadID client)
	modifyMVar_ (clientCallbacks client) (\_ -> return Data.Map.empty)
	modifyMVar_ (clientSignalHandlers client) (\_ -> return [])
:

:d DBus.Client
sendHello :: Client -> IO ()
sendHello client = void (callBlocking client (MethodCall
	{ methodCallDestination = Just "org.freedesktop.DBus"
	, methodCallMember = "Hello"
	, methodCallInterface = Just "org.freedesktop.DBus"
	, methodCallPath = "/org/freedesktop/DBus"
	, methodCallFlags = Data.Set.empty
	, methodCallBody = []
	}))
:

:d DBus.Client
send_ :: Message msg => Connection -> msg -> (Serial -> IO a) -> IO a
send_ connection msg io = do
	result <- send connection msg io
	case result of
		Right serial -> return serial
		Left err -> throwError ("Error sending message: " ++ show err)

call :: Client
     -> MethodCall
     -> (Error -> IO ())
     -> (MethodReturn -> IO ())
     -> IO ()
call client msg onError onReply = do
	let callback (ReceivedError _ _ err) = onError err
	    callback (ReceivedMethodReturn _ _ reply) = onReply reply
	    callback _ = return ()
	
	send_ (clientConnection client) msg
		(\serial -> do
			let mvar = clientCallbacks client
			modifyMVar_ mvar (\callbacks ->
				return (Data.Map.insert serial callback callbacks)))

callBlocking :: Client -> MethodCall -> IO (Either Error MethodReturn)
callBlocking client msg = do
	mvar <- newEmptyMVar
	call client msg
		(putMVar mvar . Left)
		(putMVar mvar . Right)
	takeMVar mvar
:

:d DBus.Client
mainLoop :: Client -> IO ()
mainLoop client = forever (receive >>= dispatch) where
	connection = clientConnection client
	
	receive = do
		received <- DBus.Connection.receive connection
		case received of
			Left err -> do
				detach client
				disconnect connection
				throwError ("Received invalid message: " ++ show err)
			Right msg -> return msg
	
	dispatch received@(ReceivedMethodReturn _ _ msg) = onReply (methodReturnSerial msg) received
	dispatch received@(ReceivedError _ _ msg) = onReply (errorSerial msg) received
	dispatch (ReceivedSignal _ _ _) = return ()
	dispatch (ReceivedMethodCall _ _ _) = return ()
	dispatch (ReceivedUnknown _ _ _) = return ()
	
	onReply serial msg = do
		let mvar = clientCallbacks client
		maybeCB <- modifyMVar mvar $ \callbacks -> let
			x = Data.Map.lookup serial callbacks
			callbacks' = if isJust x
				then Data.Map.delete serial callbacks
				else callbacks
			in return (callbacks', x)
		case maybeCB of
			Just cb -> void (forkIO (cb msg))
			Nothing -> return ()
:

\clearpage
\subsection{Simple clients}

:d DBus.Client.Simple
connectFirst :: [Address] -> IO Client
connectFirst addrs = loop addrs >>= attach where
	loop [] = throwError (concat
		[ "connectFirst: no usable"
		, " addresses in "
		, show addrs])
	loop (a:as) = Control.Exception.catch
		(DBus.Connection.connect a)
		(\(ConnectionError _) -> loop as)

connectSession :: IO Client
connectSession = do
	env <- DBus.Address.getSession
	case env of
		Nothing -> throwError (concat
			[ "connectSession: DBUS_SESSION_BUS_ADDRESS is"
			, " missing or invalid."
			])
		Just addrs -> connectFirst addrs

connectSystem :: IO Client
connectSystem = do
	env <- DBus.Address.getSystem
	case env of
		Nothing -> throwError (concat
			[ "connectSession: DBUS_SYSTEM_BUS_ADDRESS is"
			, " invalid."
			])
		Just addrs -> connectFirst addrs

connectStarter :: IO Client
connectStarter = do
	env <- DBus.Address.getStarter
	case env of
		Nothing -> throwError (concat
			[ "connectSession: DBUS_STARTER_BUS_ADDRESS is"
			, " missing or invalid."
			])
		Just addrs -> connectFirst addrs

disconnect :: Client -> IO ()
disconnect client = do
	let connection = clientConnection client
	detach client
	DBus.Connection.disconnect connection
:

:d DBus.Client.Simple
data Proxy = Proxy Client BusName ObjectPath
:

:d DBus.Client.Simple
proxy :: Client -> BusName -> ObjectPath -> IO Proxy
proxy client dest path = return (Proxy client dest path)
:

:d DBus.Client.Simple
call :: Proxy -> InterfaceName -> MemberName -> [Variant] -> IO (Either Error [Variant])
call (Proxy client dest path) iface member body = do
	response <- callBlocking client $ MethodCall
		{ methodCallDestination = Just dest
		, methodCallMember = member
		, methodCallInterface = Just iface
		, methodCallPath = path
		, methodCallFlags = Data.Set.empty
		, methodCallBody = body
		}
	case response of
		Left err -> return (Left err)
		Right ret -> return (Right (methodReturnBody ret))

call_ :: Proxy -> InterfaceName -> MemberName -> [Variant] -> IO [Variant]
call_ proxy' iface member body = do
	result <- call proxy' iface member body
	case result of
		Left err -> throwError ("Call failed: " ++ Data.Text.unpack (errorMessage err))
		Right ret -> return ret
:
