:# Copyright (C) 2009-2011 John Millikin <jmillikin@gmail.com>
:# 
:# This program is free software: you can redistribute it and/or modify
:# it under the terms of the GNU General Public License as published by
:# the Free Software Foundation, either version 3 of the License, or
:# any later version.
:# 
:# This program is distributed in the hope that it will be useful,
:# but WITHOUT ANY WARRANTY; without even the implied warranty of
:# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
:# GNU General Public License for more details.
:# 
:# You should have received a copy of the GNU General Public License
:# along with this program.  If not, see <http://www.gnu.org/licenses/>.

\section{Values and types}

\dbus{} values are divided into two categories, \emph{atoms} and
\emph{containers}. Atoms are strings, numbers, and so on. Containers can
store other values, including other containers. Generally, values act like
their Haskell equivalents, with one important exception: \dbus{} dictionaries
only support atomic keys. Every \dbus{} type has a \emph{type code}, a short
string describing what sort of data the value stores.

\begin{table}[h]
\label{tab:dbus-types}
\caption{\dbus{} Types}
\begin{center}
\begin{tabular}{llll}
\toprule
\dbus{} Type  & Code    & Description & Haskell Type \\
\midrule
Boolean     & {\tt b} & {\tt True} or {\tt False} & {\tt Bool} \\
Byte        & {\tt y} & 8-bit unsigned integer & {\tt Word8} \\
Int16       & {\tt n} & 16-bit signed integer & {\tt Int16} \\
UInt16      & {\tt q} & 16-bit unsigned integer & {\tt Word16} \\
Int32       & {\tt i} & 32-bit signed integer & {\tt Int32} \\
UInt32      & {\tt u} & 32-bit unsigned integer & {\tt Word32} \\
Int64       & {\tt x} & 64-bit signed integer & {\tt Int64} \\
UInt64      & {\tt t} & 64-bit unsigned integer & {\tt Word64} \\
Double      & {\tt d} & 64-bit IEEE754 floating-point & {\tt Double} \\
String      & {\tt s} & Unicode text & {\tt Text} \\
Object Path & {\tt o} & \dbus{} remote object path & {\tt DBus.Types.ObjectPath} \\
Signature   & {\tt g} & List of \dbus{} types & {\tt DBus.Types.Signature} \\
Variant     & {\tt v} & Can contain any \dbus{} value & {\tt DBus.Types.Variant} \\
Array       & {\tt a}\emph{t} & Homogenous list of \emph{t} & {\tt Vector} \\
Dictionary  & {\tt a\{}\emph{k}\emph{t}{\tt \}} & Associative map of \emph{k} to \emph{t} & {\tt Map} \\
Structure   & {\tt (}\emph{codes}{\tt )} & Heterogeneous list of \dbus{} values & Tuples \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection*{Values and types (continued)}

\begin{multicols}{2}

Since the set of types is fixed, they are internally stored as an enumeration,
named {\tt Type}. The names mostly match the \dbus{} names, but a few have
been slightly changed to conform with Haskell naming conventions.

\vfill

\columnbreak

:d DBus.Types
data Type
	= TypeBoolean
	| TypeWord8
	| TypeWord16
	| TypeWord32
	| TypeWord64
	| TypeInt16
	| TypeInt32
	| TypeInt64
	| TypeDouble
	| TypeString
	| TypeSignature
	| TypeObjectPath
	| TypeVariant
	| TypeArray Type
	| TypeDictionary Type Type
	| TypeStructure [Type]
	deriving (Eq, Ord)
:

\end{multicols}

\begin{multicols}{2}

I have two choices when deciding how to show {\tt Type}s; either use type
codes, as in signatures, or try to generate a more Haskell-ish format. I
chose the second option because it's easier to read; for example, compare
{\tt "a\{sas\}"} and {\tt Map String [String]}. This is particularly
important when working with complex or deeply-nested structures, which are
common in some APIs.

\vfill
\columnbreak

:d DBus.Types
instance Show Type where
	showsPrec d = showString . showType (d > 10)

showType :: Bool -> Type -> String
showType paren t = case t of
	TypeBoolean -> "Bool"
	TypeWord8 -> "Word8"
	TypeWord16 -> "Word16"
	TypeWord32 -> "Word32"
	TypeWord64 -> "Word64"
	TypeInt16 -> "Int16"
	TypeInt32 -> "Int32"
	TypeInt64 -> "Int64"
	TypeDouble -> "Double"
	TypeString -> "String"
	TypeSignature -> "Signature"
	TypeObjectPath -> "ObjectPath"
	TypeVariant -> "Variant"
	TypeArray t' -> concat ["[", show t', "]"]
	TypeDictionary kt vt -> showParen paren (
	                        showString "Map " .
	                        shows kt .
	                        showString " " .
	                        showsPrec 11 vt) ""
	TypeStructure ts -> concat
		["(", intercalate ", " (map show ts), ")"]
:

\end{multicols}

\clearpage
\subsection{Type signatures}

\begin{multicols}{2}

A list of types is called a \emph{signature}. Signatures are traditionally
represented as a string of type codes, such as {\tt "a\{sas\}"} for
{\tt Map String [String]}. However, this library stores signatures as
{\tt [Type]} to take advantage of Haskell's strong typing.

\vfill

\columnbreak

:d DBus.Types
newtype Signature = Signature [Type]
	deriving (Eq, Ord)

signatureTypes :: Signature -> [Type]
signatureTypes (Signature types) = types

instance Show Signature where
	showsPrec d sig = showParen (d > 10) $
		showString "Signature " .
		shows (signatureText sig)
:

\end{multicols}

\begin{multicols}{2}

Although signatures are strongly-typed internally, they are exposed to the
user as if they're special strings matching the \dbus{} signature format.

\vfill

\columnbreak

:d DBus.Types
signatureText :: Signature -> Text
signatureText = Data.Text.Encoding.decodeASCII
              . Data.ByteString.Char8.pack
              . concatMap typeCode
              . signatureTypes

typeCode :: Type -> String
typeCode TypeBoolean    = "b"
typeCode TypeWord8      = "y"
typeCode TypeWord16     = "q"
typeCode TypeWord32     = "u"
typeCode TypeWord64     = "t"
typeCode TypeInt16      = "n"
typeCode TypeInt32      = "i"
typeCode TypeInt64      = "x"
typeCode TypeDouble     = "d"
typeCode TypeString     = "s"
typeCode TypeSignature  = "g"
typeCode TypeObjectPath = "o"
typeCode TypeVariant    = "v"
typeCode (TypeArray t)  = 'a' : typeCode t
typeCode (TypeDictionary kt vt) = concat
	[ "a{", typeCode kt , typeCode vt, "}"]

typeCode (TypeStructure ts) = concat
	["(", concatMap typeCode ts, ")"]
:

\end{multicols}

\clearpage
\subsubsection*{Parsing signatures}

\begin{multicols}{2}

Signature parsing is the most common operation when unmarshaling messages;
therefore, an efficient parsing implementation is essential. However, I still
want the library's users to see a text-based interface to signatures.

Therefore, there are actually two signature parsing APIs -- one for other
modules in this library (especially {\tt DBus.Wire}, and a small wrapper for
users. The wrapper follows the pattern for other special strings, so users
can use string literals and so on.

\vfill

\columnbreak

:d DBus.Types
instance Data.String.IsString Signature where
	fromString = signature_ . Data.Text.pack

signature :: Text -> Maybe Signature
signature text = parseSignature bytes where
	bytes = Data.Text.Encoding.encodeUtf8 text

signature_ :: Text -> Signature
signature_ = tryParse "signature" signature
:

\end{multicols}

\begin{multicols}{2}

\noindent There are three special cases which can be optimized:

\begin{enumerate}
\item Empty signatures occur when messages have no body, and can use a constant
      result.
\item Single-character signatures occur when parsing variants, and can use a
      faster non-recursive parser.
\item All signatures larger than 255 characters are invalid, so they can be
      failed immediately.
\end{enumerate}

\vfill
\columnbreak

:d DBus.Types
parseSignature :: ByteString -> Maybe Signature
parseSignature bytes =
	case Data.ByteString.length bytes of
		0 -> Just (Signature [])
		1 -> parseSigFast bytes
		len | len <= 255 -> parseSigFull bytes
		_ -> Nothing
:

\end{multicols}

\begin{multicols}{2}

Additionally, the library might already has a list of {\tt Type}s available,
and just wants to see if they're a valid signature. Rather than re-parsing
them, we can assume the types are already nested correctly, and just check
their string length.

\vfill
\columnbreak

:d DBus.Types
checkSignature :: [Type] -> Maybe Signature
checkSignature = check where
	check ts = if sumLen ts > 255
		then Nothing
		else Just (Signature ts)
	sumLen :: [Type] -> Int
	sumLen = sum . map len

	len (TypeArray t) = 1 + len t
	len (TypeDictionary kt vt) = 3 + len kt + len vt
	len (TypeStructure ts) = 2 + sumLen ts
	len _ = 1
:

\end{multicols}

\clearpage
\subsubsection*{Fast signature parser}

\begin{multicols}{2}

The fast parser relies on all atoms having single-character codes; if the
input string has only one character, it must be either an atomic type or
{\tt TypeVariant}.

This optimization is important when parsing variants, as they very often
contain signatures with only a single atomic type.

\vfill
\columnbreak

:d DBus.Types
parseSigFast :: ByteString -> Maybe Signature
parseSigFast bytes =
	let byte = Data.ByteString.head bytes in
	parseAtom byte
		(\t -> Just (Signature [t]))
		(case byte of
			0x76 -> Just (Signature [TypeVariant])
			_ -> Nothing)

parseAtom :: Word8 -> (Type -> a) -> a -> a
parseAtom byte yes no = case byte of
	0x62 -> yes TypeBoolean
	0x6E -> yes TypeInt16
	0x69 -> yes TypeInt32
	0x78 -> yes TypeInt64
	0x79 -> yes TypeWord8
	0x71 -> yes TypeWord16
	0x75 -> yes TypeWord32
	0x74 -> yes TypeWord64
	0x64 -> yes TypeDouble
	0x73 -> yes TypeString
	0x67 -> yes TypeSignature
	0x6F -> yes TypeObjectPath
	_ -> no
:

\end{multicols}

\clearpage
\subsubsection*{Full signature parser}

This is horrible, gnarly, and almost completely undocumented. Someday I'll get
around to cleaning it up, or at least hanging some curtains on it.

:d DBus.Types
parseSigFull :: ByteString -> Maybe Signature
parseSigFull bytes = unsafePerformIO io where
	io = Data.ByteString.Unsafe.unsafeUseAsCStringLen bytes castBuf
	castBuf (ptr, len) = parseSigBuf (Foreign.castPtr ptr, len)
	parseSigBuf (buf, len) = mainLoop [] 0 where
		|full signature parser|
:

:d full signature parser
mainLoop acc ii | ii >= len = return (Just (Signature (reverse acc)))
mainLoop acc ii = do
	c <- Foreign.peekElemOff buf ii
	let next t = mainLoop (t : acc) (ii + 1)
	parseAtom c next $ case c of
		0x76 -> next TypeVariant
		0x28 -> do -- '('
			mt <- structure (ii + 1)
			case mt of
				Just (ii', t) -> mainLoop (t : acc) ii'
				Nothing -> return Nothing
		0x61 -> do -- 'a'
			mt <- array (ii + 1)
			case mt of
				Just (ii', t) -> mainLoop (t : acc) ii'
				Nothing -> return Nothing
		_ -> return Nothing
:

:d full signature parser
structure :: Int -> IO (Maybe (Int, Type))
structure = loop [] where
	loop _ ii | ii >= len = return Nothing
	loop acc ii = do
		c <- Foreign.peekElemOff buf ii
		let next t = loop (t : acc) (ii + 1)
		parseAtom c next $ case c of
			0x76 -> next TypeVariant
			0x28 -> do -- '('
				mt <- structure (ii + 1)
				case mt of
					Just (ii', t) -> loop (t : acc) ii'
					Nothing -> return Nothing
			0x61 -> do -- 'a'
				mt <- array (ii + 1)
				case mt of
					Just (ii', t) -> loop (t : acc) ii'
					Nothing -> return Nothing
			-- ')'
			0x29 -> return $ case acc of
				[] -> Nothing
				_ -> Just $ (ii + 1, TypeStructure (reverse acc))
			_ -> return Nothing
:

\clearpage
\subsubsection*{Full signature parser (continued)}

:d full signature parser
array :: Int -> IO (Maybe (Int, Type))
array ii | ii >= len = return Nothing
array ii = do
	c <- Foreign.peekElemOff buf ii
	let next t = return $ Just (ii + 1, TypeArray t)
	parseAtom c next $ case c of
		0x76 -> next TypeVariant
		0x7B -> dict (ii + 1) -- '{'
		0x28 -> do -- '('
			mt <- structure (ii + 1)
			case mt of
				Just (ii', t) -> return $ Just (ii', TypeArray t)
				Nothing -> return Nothing
		0x61 -> do -- 'a'
			mt <- array (ii + 1)
			case mt of
				Just (ii', t) -> return $ Just (ii', TypeArray t)
				Nothing -> return Nothing
		_ -> return Nothing
:

:d full signature parser
dict :: Int -> IO (Maybe (Int, Type))
dict ii | ii + 1 >= len = return Nothing
dict ii = do
	c1 <- Foreign.peekElemOff buf ii
	c2 <- Foreign.peekElemOff buf (ii + 1)
	
	let next t = return (Just (ii + 2, t))
	mt2 <- parseAtom c2 next $ case c2 of
		0x76 -> next TypeVariant
		0x28 -> structure (ii + 2) -- '('
		0x61 -> array (ii + 2) -- 'a'
		_ -> return Nothing
	
	case mt2 of
		Nothing -> return Nothing
		Just (ii', t2) -> if ii' >= len
			then return Nothing
			else do
				c3 <- Foreign.peekElemOff buf ii'
				return $ do
					if c3 == 0x7D then Just () else Nothing
					t1 <- parseAtom c1 Just Nothing
					Just (ii' + 1, TypeDictionary t1 t2)
:

\clearpage
\subsection{Generic value boxing}

\begin{multicols}{2}

The \dbus{} type system is similar to Haskell's, but has some minor
differences. Most notably, {\em variants} can store any \dbus{} type, and
dictionaries must have atomic keys. To provide a clean interface for
converting between \dbus{} and Haskell types, the interface is encoded with
three classes:

\begin{enumerate}
\item {\tt IsVariant} is the most general, and the only class that users may
      add instances for. Any type that can be converted to primitive \dbus{}
      values can be stored in a {\tt Variant}, and converted safely back to
      its original form.
\item {\tt IsValue} is slightly stricter, and is used for constraining
      container values. If containers were constrained to {\tt IsVariant},
      users could define an instance for {\tt Either} and create heterogenous
      containers.
\item {\tt IsAtom} is the strictest, and is used for constraining dictionary
      key types. Only atomic values can be converted with this class, and
      users cannot define their own instances.
\end{enumerate}

It is possible to make this slightly less verbose by using existential
types, but the additional indirection causes slower message parsing.

As a special optimization, arrays of bytes can be stored directly in a
{\tt Value} in three common formats. This allows the marshaling system to
avoid copying data unless needed.

{\tt ValueVector} and {\tt ValueMap} require special handling. \dbus{} needs
to know their full type even if they're empty, but {\tt ([] :: [Value])}
contains no information about its contents. As a workaround, the full type
of the container is stored in the box itself at construction.

\vfill

\columnbreak

:d DBus.Types
class IsVariant a where
	toVariant :: a -> Variant
	fromVariant :: Variant -> Maybe a

class IsVariant a => IsValue a where
	typeOf :: a -> Type
	toValue :: a -> Value
	fromValue :: Value -> Maybe a

class IsValue a => IsAtom a where
	toAtom :: a -> Atom
	fromAtom :: Atom -> Maybe a

|apidoc DBus.Types.Variant|
newtype Variant = Variant Value
	deriving (Eq)

data Value
	= ValueAtom Atom
	| ValueVariant Variant
	| ValueStrictBytes ByteString
	| ValueLazyBytes Data.ByteString.Lazy.ByteString
	| ValueVector Type (Vector Value)
	| ValueMap Type Type (Map Atom Value)
	| ValueStructure [Value]
	deriving (Show)

data Atom
	= AtomBool Bool
	| AtomWord8 Word8
	| AtomWord16 Word16
	| AtomWord32 Word32
	| AtomWord64 Word64
	| AtomInt16 Int16
	| AtomInt32 Int32
	| AtomInt64 Int64
	| AtomDouble Double
	| AtomText Text
	| AtomSignature Signature
	| AtomObjectPath ObjectPath
	deriving (Show, Eq, Ord)
:

\end{multicols}

\clearpage
\subsubsection*{Generic value boxing (continued)}

The byte-handling optimization comes at a cost, however; it's no longer
possible to derive {\tt Eq}, and the instance is quite ugly.

:d DBus.Types
instance Eq Value where
	(==) (ValueStrictBytes x) y = case y of
		ValueStrictBytes y' -> x == y'
		ValueLazyBytes y' -> Data.ByteString.Lazy.fromChunks [x] == y'
		ValueVector TypeWord8 y' -> x == vectorToBytes y'
		_ -> False
	
	(==) (ValueLazyBytes x) y = case y of
		ValueStrictBytes y' -> x == Data.ByteString.Lazy.fromChunks [y']
		ValueLazyBytes y' -> x == y'
		ValueVector TypeWord8 y' -> x == Data.ByteString.Lazy.fromChunks [vectorToBytes y']
		_ -> False
		
	(==) (ValueVector TypeWord8 x) y = case y of
		ValueStrictBytes y' -> vectorToBytes x == y'
		ValueLazyBytes y' -> Data.ByteString.Lazy.fromChunks [vectorToBytes x] == y'
		ValueVector TypeWord8 y' -> x == y'
		_ -> False
	
	(==) (ValueAtom x) (ValueAtom y) = x == y
	(==) (ValueVariant x) (ValueVariant y) = x == y
	(==) (ValueVector tx x) (ValueVector ty y) = tx == ty && x == y
	(==) (ValueMap ktx vtx x) (ValueMap kty vty y) = ktx == kty && vtx == vty && x == y
	(==) (ValueStructure x) (ValueStructure y) = x == y
	(==) _ _ = False
:

\clearpage
\subsubsection*{Generic value boxing (continued)}

If a user is interacting with the library through an REPL (e.g. GHCI), they
might want to print the content of a variant -- for example, to print messages
received from the bus. Due to the various wrappers between {\tt Variant} and
the actual data, this is somewhat complex.

:d DBus.Types
showAtom :: Bool -> Atom -> String
showAtom _ (AtomBool x) = show x
showAtom _ (AtomWord8 x) = show x
showAtom _ (AtomWord16 x) = show x
showAtom _ (AtomWord32 x) = show x
showAtom _ (AtomWord64 x) = show x
showAtom _ (AtomInt16 x) = show x
showAtom _ (AtomInt32 x) = show x
showAtom _ (AtomInt64 x) = show x
showAtom _ (AtomDouble x) = show x
showAtom _ (AtomText x) = show x
showAtom p (AtomSignature x) = showsPrec (if p then 11 else 0) x ""
showAtom p (AtomObjectPath x) = showsPrec (if p then 11 else 0) x ""

showValue :: Bool -> Value -> String
showValue p (ValueAtom x) = showAtom p x
showValue p (ValueVariant x) = showsPrec (if p then 11 else 0) x ""
showValue _ (ValueStrictBytes xs) = 'b' : show xs
showValue _ (ValueLazyBytes xs) = 'b' : show (Data.ByteString.concat (Data.ByteString.Lazy.toChunks xs))
showValue _ (ValueVector TypeWord8 xs) = 'b' : show (vectorToBytes xs)
showValue _ (ValueVector _ xs) = showThings "[" (showValue False) "]" (Data.Vector.toList xs)
showValue _ (ValueMap _ _ xs) = showThings "{" showPair "}" (Data.Map.toList xs) where
	showPair (k, v) = showAtom False k ++ ": " ++ showValue False v
showValue _ (ValueStructure xs) = showThings "(" (showValue False) ")" xs

showThings :: String -> (a -> String) -> String -> [a] -> String
showThings a s z xs = a ++ intercalate ", " (map s xs) ++ z

vectorToBytes :: Vector Value -> ByteString
vectorToBytes = Data.ByteString.pack
              . Data.Vector.toList
              . Data.Vector.map (\(ValueAtom (AtomWord8 x)) -> x)
:

To preserve the variant-based public interface, {\tt showAtom} and
{\tt showValue} are not exported to the user. This preserves the
appearance that {\tt Variant} is a simple wrapping box.

\begin{quote}
:d DBus.Types
instance Show Variant where
	showsPrec d (Variant x) = showParen (d > 10) $
		showString "Variant " .  showString (showValue True x)
:
\end{quote}

\clearpage
\subsubsection*{Generic value boxing (continued)}

Printing a {\tt Variant} lets the user see what value it contains, but
sometimes they need to know exactly what type \dbus{} thinks it is. This
is particularly important when working with integers, as some APIs will
only accept integers of a particular size.

:d DBus.Types
|apidoc DBus.Types.variantType|
variantType :: Variant -> Type
variantType (Variant val) = valueType val

valueType :: Value -> Type
valueType (ValueAtom x) = atomType x
valueType (ValueVariant _) = TypeVariant
valueType (ValueVector t _) = TypeArray t
valueType (ValueStrictBytes _) = TypeArray TypeWord8
valueType (ValueLazyBytes _) = TypeArray TypeWord8
valueType (ValueMap kt vt _) = TypeDictionary kt vt
valueType (ValueStructure vs) = TypeStructure (map valueType vs)

atomType :: Atom -> Type
atomType (AtomBool _) = TypeBoolean
atomType (AtomWord8 _) = TypeWord8
atomType (AtomWord16 _) = TypeWord16
atomType (AtomWord32 _) = TypeWord32
atomType (AtomWord64 _) = TypeWord64
atomType (AtomInt16 _) = TypeInt16
atomType (AtomInt32 _) = TypeInt32
atomType (AtomInt64 _) = TypeInt64
atomType (AtomDouble _) = TypeDouble
atomType (AtomText _) = TypeString
atomType (AtomSignature _) = TypeSignature
atomType (AtomObjectPath _) = TypeObjectPath
:

\clearpage
\subsection{Special string types}

Various aspects of \dbus{} require the use of specially-formatted strings. Every
special string type gets its own Haskell type and construction function; this
allows the library to assume all such strings are correctly formatted. The
constructors will evaluate to {\tt Nothing} if their input is invalid. In
addition, partial versions (suffixed with {\tt \_}) are available for users
who don't care about validation; these will throw an exception if the input
is invalid. Finally, {\tt IsString} instances are available for all special
strings, so users can just enable {\tt OverloadedStrings} and use string
literals directly.

Validation is performed using Parsec. Unfortunately, Parsec does not work
with packed strings; I'll define a few utility functions first, so the
validation logic is more obvious. Note that these discard the Parsec error
message; if some input doesn't match, the exact error is unlikely to be
interesting.

:d text validation imports
import qualified Text.ParserCombinators.Parsec as Parsec
import           Text.ParserCombinators.Parsec ((<|>), oneOf)
:

:d text validation
skipSepBy1 :: Parsec.Parser a -> Parsec.Parser b -> Parsec.Parser ()
skipSepBy1 p sep = do
	void p
	Parsec.skipMany (sep >> p)

runParser :: Parsec.Parser a -> Text -> Maybe a
runParser parser text = case Parsec.parse parser "" (Data.Text.unpack text) of
	Left _ -> Nothing
	Right a -> Just a

tryParse :: String -> (Text -> Maybe a) -> Text -> a
tryParse label parse text = case parse text of
	Just x -> x
	Nothing -> error ("Invalid " ++ label ++ ": " ++ show text)
:

\clearpage
\subsubsection{Object paths}

\begin{multicols}{2}

\dbus{} is an object-oriented protocol; most \dbus{} sessions consist of method
calls sent to \emph{objects} exported by other applications. An objects is
identified by a \emph{object path}, such as {\tt /org/freedesktop/DBus}, which
is unique within each application.

\vfill

\columnbreak

:d DBus.Types
newtype ObjectPath = ObjectPath Text
	deriving (Eq, Ord, Show)

objectPathText :: ObjectPath -> Text
objectPathText (ObjectPath text) = text

objectPath :: Text -> Maybe ObjectPath
objectPath text = do
	runParser parseObjectPath text
	return (ObjectPath text)

objectPath_ :: Text -> ObjectPath
objectPath_ = tryParse "object path" objectPath

instance Data.String.IsString ObjectPath where
	fromString = objectPath_ . Data.Text.pack

instance IsAtom ObjectPath where
	toAtom = AtomObjectPath
	fromAtom (AtomObjectPath x) = Just x
	fromAtom _ = Nothing

instance IsValue ObjectPath where
	typeOf _ = TypeObjectPath
	toValue = atomToValue
	fromValue = atomFromValue

instance IsVariant ObjectPath where
	toVariant = Variant . toValue
	fromVariant (Variant val) = fromValue val
:

\end{multicols}

\begin{multicols}{2}

An object path may be one of

\begin{itemize}
\item The root path, {\tt "/"}.
\item {\tt '/'}, followed by one or more elements, separated by {\tt '/'}.
      Each element contains characters in the set {\tt [a-zA-Z0-9\_]}, and
      must have at least one character.
\end{itemize}

Element names are separated by {\tt '/'}, and the path may not end in
{\tt '/'} unless it is the root path.

\vfill

\columnbreak

:d DBus.Types
parseObjectPath :: Parsec.Parser ()
parseObjectPath = root <|> object where
	root = Parsec.try $ do
		slash
		Parsec.eof
	
	object = do
		slash
		skipSepBy1 element slash
		Parsec.eof
	
	element = Parsec.skipMany1 (oneOf chars)
	
	slash = void (Parsec.char '/')
	chars = concat [ ['a'..'z']
	               , ['A'..'Z']
	               , ['0'..'9']
	               , "_"]
:

\end{multicols}

\clearpage
\subsubsection{Interface names}

\begin{multicols}{2}

Each object may have several \emph{interfaces}, each identified by an
\emph{interface name}. Interfaces are the basic units of \dbus{} APIs, and
even simple objects are expected to contain several (such as
{\tt org.freedesktop.DBus.Introspectable} or
{\tt org.freedesktop.DBus.Properties}). They correspond generally to Haskell
classes, or Python protocols.

\vfill

\columnbreak

:d DBus.Types
newtype InterfaceName = InterfaceName Text
	deriving (Eq, Ord, Show)

interfaceNameText :: InterfaceName -> Text
interfaceNameText (InterfaceName text) = text

interfaceName :: Text -> Maybe InterfaceName
interfaceName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseInterfaceName text
	return (InterfaceName text)

interfaceName_ :: Text -> InterfaceName
interfaceName_ = tryParse "interface name" interfaceName

instance Data.String.IsString InterfaceName where
	fromString = interfaceName_ . Data.Text.pack

instance IsVariant InterfaceName where
	toVariant = toVariant . interfaceNameText
	fromVariant v = fromVariant v >>= interfaceName
:

\end{multicols}

\begin{multicols}{2}

An interface name consists of two or more {\tt '.'}-separated elements. Each
element constists of characters from the set {\tt [a-zA-Z0-9\_]}, may not
start with a digit, and must have at least one character.

\vfill

\columnbreak

:d DBus.Types
parseInterfaceName :: Parsec.Parser ()
parseInterfaceName = name >> Parsec.eof where
	alpha = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
	alphanum = alpha ++ ['0'..'9']
	element = do
		void (oneOf alpha)
		Parsec.skipMany (oneOf alphanum)
	name = do
		element
		void (Parsec.char '.')
		skipSepBy1 element (Parsec.char '.')
:

\end{multicols}

\clearpage
\subsubsection{Member names}

\begin{multicols}{2}

An interface, in turn, contains several \emph{members}, each identified by a
\emph{member name} such as {\tt Introspect}. A member might be either a
\emph{method}, which clients can call, or a \emph{signal}, which clients can
wait for.

\vfill

\columnbreak

:d DBus.Types
newtype MemberName = MemberName Text
	deriving (Eq, Ord, Show)

memberNameText :: MemberName -> Text
memberNameText (MemberName text) = text

memberName :: Text -> Maybe MemberName
memberName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseMemberName text
	return (MemberName text)

memberName_ :: Text -> MemberName
memberName_ = tryParse "member name" memberName

instance Data.String.IsString MemberName where
	fromString = memberName_ . Data.Text.pack

instance IsVariant MemberName where
	toVariant = toVariant . memberNameText
	fromVariant v = fromVariant v >>= memberName
:

\end{multicols}

\begin{multicols}{2}

Member names must contain only characters from the set {\tt [a-zA-Z0-9\_]},
may not begin with a digit, and must be at least one character long.

\vfill

\columnbreak

:d DBus.Types
parseMemberName :: Parsec.Parser ()
parseMemberName = name >> Parsec.eof where
	alpha = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
	alphanum = alpha ++ ['0'..'9']
	name = do
		void (oneOf alpha)
		Parsec.skipMany (oneOf alphanum)
:

\end{multicols}

\clearpage
\subsubsection{Error names}

\begin{multicols}{2}

Every error returned from a method call has an \emph{error name}, so
clients can know (generally) what went wrong without having to parse the
error message. Applications may define their own error names, or use one
of the standardized names listed in appendix~\ref{sec:standard-error-names}.

Error names have the same format as interface names, so the parser logic
can be reused.

\vfill

\columnbreak

:d DBus.Types
newtype ErrorName = ErrorName Text
	deriving (Eq, Ord, Show)

errorNameText :: ErrorName -> Text
errorNameText (ErrorName text) = text

errorName :: Text -> Maybe ErrorName
errorName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseInterfaceName text
	return (ErrorName text)

errorName_ :: Text -> ErrorName
errorName_ = tryParse "error name" errorName

instance Data.String.IsString ErrorName where
	fromString = errorName_ . Data.Text.pack

instance IsVariant ErrorName where
	toVariant = toVariant . errorNameText
	fromVariant v = fromVariant v >>= errorName
:

\end{multicols}

\clearpage
\subsubsection{Bus names}

\begin{multicols}{2}

Bus names are used when connecting to a central message dispatch bus. Every
connection is assigned a \emph{unique name}, such as {\tt :103.1}. This name
is usually used by the bus to send signals and method returns to client
applications.

Additionally, applications may request a \emph{well-known} name such as
{\tt org.freedesktop.DBus}. These are similar to internet hostnames; client
applications are written to send messages to this address, where they can be
served by whatever server happens to be running at the time.

\vfill

\columnbreak

:d DBus.Types
newtype BusName = BusName Text
	deriving (Eq, Ord, Show)

busNameText :: BusName -> Text
busNameText (BusName text) = text

busName :: Text -> Maybe BusName
busName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseBusName text
	return (BusName text)

busName_ :: Text -> BusName
busName_ = tryParse "bus name" busName

instance Data.String.IsString BusName where
	fromString = busName_ . Data.Text.pack

instance IsVariant BusName where
	toVariant = toVariant . busNameText
	fromVariant v = fromVariant v >>= busName
:

\end{multicols}

\begin{multicols}{2}

Unique names begin with {\tt `:'} and contain two or more elements, separated
by {\tt `.'}. Each element consists of characters from the set
{\tt [a-zA-Z0-9\_-]}.

Well-known names contain two or more elements, separated by {\tt `.'}. Each
element consists of characters from the set {\tt [a-zA-Z0-9\_-]}, and must
not start with a digit.

\vfill

\columnbreak

:d DBus.Types
parseBusName :: Parsec.Parser ()
parseBusName = name >> Parsec.eof where
	alpha = ['a'..'z'] ++ ['A'..'Z'] ++ "_-"
	alphanum = alpha ++ ['0'..'9']
	
	name = unique <|> wellKnown
	unique = do
		void (Parsec.char ':')
		elements alphanum
	
	wellKnown = elements alpha
	
	elements start = do
		element start
		Parsec.skipMany1 $ do
			void (Parsec.char '.')
			element start
	
	element start = do
		void (oneOf start)
		Parsec.skipMany (oneOf alphanum)
:

\end{multicols}

\clearpage
\subsection{Container boxes}

:d DBus.Types
newtype Structure = Structure [Value]
	deriving (Eq)

instance Show Structure where
	show (Structure xs) = showValue True (ValueStructure xs)

instance IsVariant Structure where
	toVariant (Structure xs) = Variant (ValueStructure xs)
	fromVariant (Variant (ValueStructure xs)) = Just (Structure xs)
	fromVariant _ = Nothing

structureItems :: Structure -> [Variant]
structureItems (Structure xs) = map Variant xs
:

:d DBus.Types
data Array
	= Array Type (Vector Value)
	| ArrayStrictBytes ByteString
	| ArrayLazyBytes Data.ByteString.Lazy.ByteString

instance Show Array where
	show (Array t xs) = showValue True (ValueVector t xs)
	show (ArrayStrictBytes xs) = showValue True (ValueStrictBytes xs)
	show (ArrayLazyBytes xs) = showValue True (ValueLazyBytes xs)

instance Eq Array where
	x == y = norm x == norm y where
		norm (Array TypeWord8 xs) = Left (Data.ByteString.Lazy.fromChunks [vectorToBytes xs])
		norm (Array t xs) = Right (t, xs)
		norm (ArrayStrictBytes xs) = Left (Data.ByteString.Lazy.fromChunks [xs])
		norm (ArrayLazyBytes xs) = Left xs

instance IsVariant Array where
	toVariant (Array t xs) = Variant (ValueVector t xs)
	toVariant (ArrayStrictBytes bs) = Variant (ValueStrictBytes bs)
	toVariant (ArrayLazyBytes bs) = Variant (ValueLazyBytes bs)
	fromVariant (Variant (ValueVector t xs)) = Just (Array t xs)
	fromVariant (Variant (ValueStrictBytes bs)) = Just (ArrayStrictBytes bs)
	fromVariant (Variant (ValueLazyBytes bs)) = Just (ArrayLazyBytes bs)
	fromVariant _ = Nothing

arrayItems :: Array -> [Variant]
arrayItems (Array _ xs) = map Variant (Data.Vector.toList xs)
arrayItems (ArrayStrictBytes bs) = map toVariant (Data.ByteString.unpack bs)
arrayItems (ArrayLazyBytes bs) = map toVariant (Data.ByteString.Lazy.unpack bs)
:

:d DBus.Types
data Dictionary = Dictionary Type Type (Map Atom Value)
	deriving (Eq)

instance Show Dictionary where
	show (Dictionary kt vt xs) = showValue True (ValueMap kt vt xs)

instance IsVariant Dictionary where
	toVariant (Dictionary kt vt xs) = Variant (ValueMap kt vt xs)
	fromVariant (Variant (ValueMap kt vt xs)) = Just (Dictionary kt vt xs)
	fromVariant _ = Nothing

dictionaryItems :: Dictionary -> [(Variant, Variant)]
dictionaryItems (Dictionary _ _ xs) = do
	(k, v) <- Data.Map.toList xs
	return (Variant (ValueAtom k), Variant v)
:
