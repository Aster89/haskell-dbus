:# Copyright (C) 2009-2011 John Millikin <jmillikin@gmail.com>
:# 
:# This program is free software: you can redistribute it and/or modify
:# it under the terms of the GNU General Public License as published by
:# the Free Software Foundation, either version 3 of the License, or
:# any later version.
:# 
:# This program is distributed in the hope that it will be useful,
:# but WITHOUT ANY WARRANTY; without even the implied warranty of
:# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
:# GNU General Public License for more details.
:# 
:# You should have received a copy of the GNU General Public License
:# along with this program.  If not, see <http://www.gnu.org/licenses/>.

\section{Values and types}

\dbus{} values are divided into two categories, \emph{atoms} and
\emph{containers}. Atoms are strings, numbers, and so on. Containers can
store other values, including other containers. Generally, values act like
their Haskell equivalents, with one important exception: \dbus{} dictionaries
only support atomic keys. Every \dbus{} type has a \emph{type code}, a short
string describing what sort of data the value stores.

\begin{table}[h]
\label{tab:dbus-types}
\caption{\dbus{} Types}
\begin{center}
\begin{tabular}{llll}
\toprule
\dbus{} Type  & Code    & Description & Haskell Type \\
\midrule
Boolean     & {\tt b} & {\tt True} or {\tt False} & {\tt Bool} \\
Byte        & {\tt y} & 8-bit unsigned integer & {\tt Word8} \\
Int16       & {\tt n} & 16-bit signed integer & {\tt Int16} \\
UInt16      & {\tt q} & 16-bit unsigned integer & {\tt Word16} \\
Int32       & {\tt i} & 32-bit signed integer & {\tt Int32} \\
UInt32      & {\tt u} & 32-bit unsigned integer & {\tt Word32} \\
Int64       & {\tt x} & 64-bit signed integer & {\tt Int64} \\
UInt64      & {\tt t} & 64-bit unsigned integer & {\tt Word64} \\
Double      & {\tt d} & 64-bit IEEE754 floating-point & {\tt Double} \\
String      & {\tt s} & Unicode text & {\tt Text} \\
Object Path & {\tt o} & \dbus{} remote object path & {\tt DBus.Types.ObjectPath} \\
Signature   & {\tt g} & List of \dbus{} types & {\tt DBus.Types.Signature} \\
Variant     & {\tt v} & Can contain any \dbus{} value & {\tt DBus.Types.Variant} \\
Array       & {\tt a}\emph{t} & Homogenous list of \emph{t} & {\tt Vector} \\
Dictionary  & {\tt a\{}\emph{k}\emph{t}{\tt \}} & Associative map of \emph{k} to \emph{t} & {\tt Map} \\
Structure   & {\tt (}\emph{codes}{\tt )} & Heterogeneous list of \dbus{} values & Tuples \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\begin{multicols}{2}

Since the set of types is fixed, they are internally stored as an enumeration,
named {\tt Type}. The names mostly match the \dbus{} names, but a few have
been slightly changed to conform with Haskell naming conventions.

\vfill

\columnbreak

:d DBus.Types
data Type
	= TypeBoolean
	| TypeWord8
	| TypeWord16
	| TypeWord32
	| TypeWord64
	| TypeInt16
	| TypeInt32
	| TypeInt64
	| TypeDouble
	| TypeString
	| TypeSignature
	| TypeObjectPath
	| TypeVariant
	| TypeArray Type
	| TypeDictionary Type Type
	| TypeStructure [Type]
	deriving (Eq, Ord)
:

\end{multicols}

\clearpage
\subsection{Type signatures}

\begin{multicols}{2}

A list of types is called a \emph{signature}. Signatures are traditionally
represented as a string of type codes, such as {\tt "a\{sas\}"} for
{\tt Map String [String]}. However, this library stores signatures as
{\tt [Type]} to take advantage of Haskell's strong typing.

Although signatures are strongly-typed internally, they are exposed to the
user as if they're special strings matching the \dbus{} signature format.
I'll get to signature parsing later, as (for performance reasons) it's
very complex.

\vfill

\columnbreak

:d DBus.Types
newtype Signature = Signature [Type]
	deriving (Eq, Ord)

signatureTypes :: Signature -> [Type]
signatureTypes (Signature types) = types

instance Show Signature where
	showsPrec d sig = showParen (d > 10) $
		showString "Signature " .
		shows (signatureText sig)
:

\end{multicols}

:d DBus.Types
signatureText :: Signature -> Text
signatureText = Data.Text.Encoding.decodeASCII
              . Data.ByteString.Char8.pack
              . concatMap typeCode
              . signatureTypes
:

\begin{multicols}{2}

:d DBus.Types
typeCode :: Type -> String
typeCode TypeBoolean    = "b"
typeCode TypeWord8      = "y"
typeCode TypeWord16     = "q"
typeCode TypeWord32     = "u"
typeCode TypeWord64     = "t"
typeCode TypeInt16      = "n"
typeCode TypeInt32      = "i"
typeCode TypeInt64      = "x"
typeCode TypeDouble     = "d"
typeCode TypeString     = "s"
typeCode TypeSignature  = "g"
typeCode TypeObjectPath = "o"
typeCode TypeVariant    = "v"
typeCode (TypeArray t)  = 'a' : typeCode t
typeCode (TypeDictionary kt vt) = concat ["a{", typeCode kt, typeCode vt, "}"]
typeCode (TypeStructure ts) = '(' : (concatMap typeCode ts ++ ")")
:

:d DBus.Types
checkSignature :: [Type] -> Maybe Signature
checkSignature = check where
	check ts = if sumLen ts > 255
		then Nothing
		else Just (Signature ts)
	sumLen :: [Type] -> Int
	sumLen = sum . map len

	len (TypeArray t) = 1 + len t
	len (TypeDictionary kt vt) = 3 + len kt + len vt
	len (TypeStructure ts) = 2 + sumLen ts
	len _ = 1
:

\columnbreak

~

~

{\tt typeCode} is a straightforward translation of table~\ref{tab:dbus-types}.
Users (and other modules in this library) will not call it directly; they
should use {\tt signatureString} instead.

\vfill

\end{multicols}

\clearpage
\subsection{Generic value boxing}

\begin{multicols}{2}

The \dbus{} type system has a few features, such as structures and
variants, that require some way to store \dbus{} values of different types
in the same container. The Haskell type system does not support this; as a
workaround, all values supported by \dbus{} can be type-safely stored in the
generic box {\tt Value}. Atomic values are stored in {\tt Atom}, so they can
be used as map keys in {\tt ValueMap}.

It is possible to make this slightly less verbose by using existential
types, but the additional indirection causes slower message parsing.

\vfill

\columnbreak

:d DBus.Types
data Value
	= ValueAtom Atom
	| ValueVariant Variant
	| ValueVector Type (Vector Value)
	| ValueMap Type (Map Atom Value)
	| ValueStructure [Value]
	deriving (Eq)

data Atom
	= AtomBool Bool
	| AtomWord8 Word8
	| AtomWord16 Word16
	| AtomWord32 Word32
	| AtomWord64 Word64
	| AtomInt16 Int16
	| AtomInt32 Int32
	| AtomInt64 Int64
	| AtomDouble Double
	| AtomText Text
	| AtomSignature Signature
	| AtomObjectPath ObjectPath
	deriving (Eq, Ord)
:

\end{multicols}

\begin{multicols}{2}

The {\tt IsValue} class exposes an interface common to all values supported
by \dbus{}. Every value has a {\tt Type}, and can be converted to/from a
{\tt Value}.

\vfill

\columnbreak

:d DBus.Types
class IsValue a where
	typeOf :: a -> Type
	toValue :: a -> Value
	fromValue :: Value -> Maybe a
:

\end{multicols}

\begin{multicols}{2}

The {\tt IsAtom} class is not strictly necessary, but it allows
users to construct dictionaries without an intermediate type validation.

\vfill

\columnbreak

:d DBus.Types
class IsValue a => IsAtom a where
	toAtom :: a -> Atom
	fromAtom :: Atom -> Maybe a
:

\end{multicols}

\subsubsection{Variants}

\begin{multicols}{2}

The {\tt toValue} function has an important invariant: values of a given
Haskell type must always be converted to the same \dbus{} type. If this
invariant is broken, homogenous containers (arrays and dictionaries) with
invalid contents can be sent over the wire. To protect {\tt toValue}, it
is not exported to library users.

However, users often want to define and work directly with their own types.
As a workaround, the {\tt IsVariant} class allows limited extension to the
supported types. The only significant restriction is that the contents of
homogenous containers must instance {\tt IsValue}.

\vfill

\columnbreak

:d DBus.Types
newtype Variant = Variant Value
	deriving (Eq)

class IsVariant a where
	toVariant :: a -> Variant
	fromVariant :: Variant -> Maybe a
:

\end{multicols}

\clearpage
\subsubsection{Inspecting boxed values}

If a user is interacting with the library through an REPL (e.g. GHCI), they
might want to print the content of a variant -- for example, to print messages
received from the bus. Due to the various wrappers between {\tt Variant} and
the actual data, this is somewhat complex.

\begin{multicols}{2}

\begin{quote}
:d DBus.Types
showAtom :: Bool -> Atom -> String
showAtom _ (AtomBool x) = show x
showAtom _ (AtomWord8 x) = show x
showAtom _ (AtomWord16 x) = show x
showAtom _ (AtomWord32 x) = show x
showAtom _ (AtomWord64 x) = show x
showAtom _ (AtomInt16 x) = show x
showAtom _ (AtomInt32 x) = show x
showAtom _ (AtomInt64 x) = show x
showAtom _ (AtomDouble x) = show x
showAtom _ (AtomText x) = show x
showAtom p (AtomSignature x) = showsPrec (if p then 11 else 0) x ""
showAtom p (AtomObjectPath x) = showsPrec (if p then 11 else 0) x ""

showValue :: Bool -> Value -> String
showValue p (ValueAtom x) = showAtom p x
showValue p (ValueVariant x) = showsPrec (if p then 11 else 0) x ""
showValue _ (ValueVector _ xs) = showThings "[" (showValue False) "]" (Data.Vector.toList xs)
showValue _ (ValueMap _ xs) = showThings "{" showPair "}" (Data.Map.toList xs) where
	showPair (k, v) = showAtom False k ++ ": " ++ showValue False v
showValue _ (ValueStructure xs) = showThings "(" (showValue False) ")" xs

showThings :: String -> (a -> String) -> String -> [a] -> String
showThings a s z xs = a ++ intercalate ", " (map s xs) ++ z
:
\end{quote}

\columnbreak

Printing {\tt Atom}s is easy; all atomic types have obvious formats, and
are supported natively by Haskell.

{\tt Value}s are a bit harder. Even if I wanted to add {\tt Show} instances
directly to {\tt Value} and {\tt Atom}, they wouldn't be suitable because
{\tt Vector} and {\tt Map} have truly bizarre {\tt Show} instances:

\begin{quote}
\begin{verbatim}
ghci> Data.Vector.singleton "foo"
fromList ["foo"] :: Data.Vector.Vector

ghci> Data.Map.singleton "foo" "bar"
fromList [("foo","bar")]
\end{verbatim}
\end{quote}

\noindent Therefore, {\tt showValue} does its own container formatting.

\vfill

\end{multicols}

To preserve the variant-based public interface, {\tt showAtom} and
{\tt showValue} are not exported to the user. This preserves the
appearance that {\tt Variant} is a simple wrapping box.

\begin{quote}
:d DBus.Types
instance Show Variant where
	showsPrec d (Variant x) = showParen (d > 10) $
		showString "Variant " .  showString (showValue True x)
:
\end{quote}

\clearpage
\subsubsection{Inspecting boxed types}

Printing a {\tt Variant} lets the user see what value it contains, but
sometimes they need to know exactly what type \dbus{} thinks it is. This
is particularly important when working with integers, as some APIs will
only accept integers of a particular size.

\begin{multicols}{2}

:d DBus.Types
variantType :: Variant -> Type
variantType (Variant val) = valueType val

valueType :: Value -> Type
valueType (ValueAtom x) = atomType x
valueType (ValueVariant _) = TypeVariant
valueType (ValueVector t _) = t
valueType (ValueMap t _) = t
valueType (ValueStructure vs) = TypeStructure (map valueType vs)

atomType :: Atom -> Type
atomType (AtomBool _) = TypeBoolean
atomType (AtomWord8 _) = TypeWord8
atomType (AtomWord16 _) = TypeWord16
atomType (AtomWord32 _) = TypeWord32
atomType (AtomWord64 _) = TypeWord64
atomType (AtomInt16 _) = TypeInt16
atomType (AtomInt32 _) = TypeInt32
atomType (AtomInt64 _) = TypeInt64
atomType (AtomDouble _) = TypeDouble
atomType (AtomText _) = TypeString
atomType (AtomSignature _) = TypeSignature
atomType (AtomObjectPath _) = TypeObjectPath
:

\columnbreak

All of {\tt Atom}'s constructors map directly to a {\tt Type}, so
implementing {\tt atomType} is trivial.

{\tt ValueVector} and {\tt ValueMap} require special handling. \dbus{} needs
to know their full type even if they're empty, but {\tt ([] :: [Value])}
contains no information about its contents. As a workaround, the full type
of the container is stored in the box itself at construction.

\end{multicols}

\begin{multicols}{2}

:d DBus.Types
instance Show Type where
	showsPrec d x = case x of
		TypeBoolean -> showString "Bool"
		TypeWord8 -> showString "Word8"
		TypeWord16 -> showString "Word16"
		TypeWord32 -> showString "Word32"
		TypeWord64 -> showString "Word64"
		TypeInt16 -> showString "Int16"
		TypeInt32 -> showString "Int32"
		TypeInt64 -> showString "Int64"
		TypeDouble -> showString "Double"
		TypeString -> showString "String"
		TypeSignature -> showString "Signature"
		TypeObjectPath -> showString "ObjectPath"
		TypeVariant -> showString "Variant"
		TypeArray t -> showString "[" . shows t . showString "]"
		TypeDictionary kt vt -> showParen (d > 10) $
			showString "Map " .  shows kt .  showString " " .  showsPrec 11 vt
		TypeStructure types -> showString (showThings "(" show ")" types)
:

\columnbreak

I have two choices when deciding how to show {\tt Type}s; can use type
codes, as in signatures, or try to generate a more Haskell-ish format. I
chose the second option because it's easier to read; for example, compare
{\tt "a\{sas\}"} and {\tt Map String [String]}. This is particularly
important when working with complex or deeply-nested structures, which are
common in some APIs.

Note that the types displayed here do not match up exactly to the actual
Haskell types used to implement the boxes. I don't want typical users to
care about how the internals work.

\vfill

\end{multicols}

\clearpage
\subsection{Special string types}

Various aspects of \dbus{} require the use of specially-formatted strings. Every
special string type gets its own Haskell type and construction function; this
allows the library to assume all such strings are correctly formatted. The
constructors will evaluate to {\tt Nothing} if their input is invalid. In
addition, partial versions (suffixed with {\tt \_}) are available for users
who don't care about validation; these will throw an exception if the input
is invalid. Finally, {\tt IsString} instances are available for all special
strings, so users can just enable {\tt OverloadedStrings} and use string
literals directly.

Validation is performed using Parsec. Unfortunately, Parsec does not work
with packed strings; I'll define a few utility functions first, so the
validation logic is more obvious. Note that these discard the Parsec error
message; if some input doesn't match, the exact error is unlikely to be
interesting.

:d text validation imports
import qualified Text.ParserCombinators.Parsec as Parsec
import           Text.ParserCombinators.Parsec ((<|>), oneOf)
:

:d text validation
skipSepBy1 :: Parsec.Parser a -> Parsec.Parser b -> Parsec.Parser ()
skipSepBy1 p sep = do
	void p
	Parsec.skipMany (sep >> p)

runParser :: Parsec.Parser a -> Text -> Maybe a
runParser parser text = case Parsec.parse parser "" (Data.Text.unpack text) of
	Left _ -> Nothing
	Right a -> Just a

tryParse :: String -> (Text -> Maybe a) -> Text -> a
tryParse label parse text = case parse text of
	Just x -> x
	Nothing -> error ("Invalid " ++ label ++ ": " ++ show text)
:

\clearpage
\subsubsection{Object paths}

\begin{multicols}{2}

\dbus{} is an object-oriented protocol; most \dbus{} sessions consist of method
calls sent to \emph{objects} exported by other applications. An objects is
identified by a \emph{object path}, such as {\tt /org/freedesktop/DBus}, which
is unique within each application.

\vfill

\columnbreak

:d DBus.Types
newtype ObjectPath = ObjectPath Text
	deriving (Eq, Ord, Show)

objectPathText :: ObjectPath -> Text
objectPathText (ObjectPath text) = text

objectPath :: Text -> Maybe ObjectPath
objectPath text = do
	runParser parseObjectPath text
	return (ObjectPath text)

objectPath_ :: Text -> ObjectPath
objectPath_ = tryParse "object path" objectPath

instance Data.String.IsString ObjectPath where
	fromString = objectPath_ . Data.Text.pack

instance IsAtom ObjectPath where
	toAtom = AtomObjectPath
	fromAtom (AtomObjectPath x) = Just x
	fromAtom _ = Nothing

instance IsValue ObjectPath where
	typeOf _ = TypeObjectPath
	toValue = atomToValue
	fromValue = atomFromValue

instance IsVariant ObjectPath where
	toVariant = Variant . toValue
	fromVariant (Variant val) = fromValue val
:

\end{multicols}

\begin{multicols}{2}

An object path may be one of

\begin{itemize}
\item The root path, {\tt "/"}.
\item {\tt '/'}, followed by one or more elements, separated by {\tt '/'}.
      Each element contains characters in the set {\tt [a-zA-Z0-9\_]}, and
      must have at least one character.
\end{itemize}

Element names are separated by {\tt '/'}, and the path may not end in
{\tt '/'} unless it is the root path.

\vfill

\columnbreak

:d DBus.Types
parseObjectPath :: Parsec.Parser ()
parseObjectPath = root <|> object where
	root = Parsec.try $ do
		slash
		Parsec.eof
	
	object = do
		slash
		skipSepBy1 element slash
		Parsec.eof
	
	element = Parsec.skipMany1 (oneOf chars)
	
	slash = void (Parsec.char '/')
	chars = concat [ ['a'..'z']
	               , ['A'..'Z']
	               , ['0'..'9']
	               , "_"]
:

\end{multicols}

\clearpage
\subsubsection{Interface names}

\begin{multicols}{2}

Each object may have several \emph{interfaces}, each identified by an
\emph{interface name}. Interfaces are the basic units of \dbus{} APIs, and
even simple objects are expected to contain several (such as
{\tt org.freedesktop.DBus.Introspectable} or
{\tt org.freedesktop.DBus.Properties}). They correspond generally to Haskell
classes, or Python protocols.

\vfill

\columnbreak

:d DBus.Types
newtype InterfaceName = InterfaceName Text
	deriving (Eq, Ord, Show)

interfaceNameText :: InterfaceName -> Text
interfaceNameText (InterfaceName text) = text

interfaceName :: Text -> Maybe InterfaceName
interfaceName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseInterfaceName text
	return (InterfaceName text)

interfaceName_ :: Text -> InterfaceName
interfaceName_ = tryParse "interface name" interfaceName

instance Data.String.IsString InterfaceName where
	fromString = interfaceName_ . Data.Text.pack

instance IsVariant InterfaceName where
	toVariant = toVariant . interfaceNameText
	fromVariant v = fromVariant v >>= interfaceName
:

\end{multicols}

\begin{multicols}{2}

An interface name consists of two or more {\tt '.'}-separated elements. Each
element constists of characters from the set {\tt [a-zA-Z0-9\_]}, may not
start with a digit, and must have at least one character.

\vfill

\columnbreak

:d DBus.Types
parseInterfaceName :: Parsec.Parser ()
parseInterfaceName = name >> Parsec.eof where
	alpha = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
	alphanum = alpha ++ ['0'..'9']
	element = do
		void (oneOf alpha)
		Parsec.skipMany (oneOf alphanum)
	name = do
		element
		void (Parsec.char '.')
		skipSepBy1 element (Parsec.char '.')
:

\end{multicols}

\clearpage
\subsubsection{Member names}

\begin{multicols}{2}

An interface, in turn, contains several \emph{members}, each identified by a
\emph{member name} such as {\tt Introspect}. A member might be either a
\emph{method}, which clients can call, or a \emph{signal}, which clients can
wait for.

\vfill

\columnbreak

:d DBus.Types
newtype MemberName = MemberName Text
	deriving (Eq, Ord, Show)

memberNameText :: MemberName -> Text
memberNameText (MemberName text) = text

memberName :: Text -> Maybe MemberName
memberName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseMemberName text
	return (MemberName text)

memberName_ :: Text -> MemberName
memberName_ = tryParse "member name" memberName

instance Data.String.IsString MemberName where
	fromString = memberName_ . Data.Text.pack

instance IsVariant MemberName where
	toVariant = toVariant . memberNameText
	fromVariant v = fromVariant v >>= memberName
:

\end{multicols}

\begin{multicols}{2}

Member names must contain only characters from the set {\tt [a-zA-Z0-9\_]},
may not begin with a digit, and must be at least one character long.

\vfill

\columnbreak

:d DBus.Types
parseMemberName :: Parsec.Parser ()
parseMemberName = name >> Parsec.eof where
	alpha = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
	alphanum = alpha ++ ['0'..'9']
	name = do
		void (oneOf alpha)
		Parsec.skipMany (oneOf alphanum)
:

\end{multicols}

\clearpage
\subsubsection{Error names}

\begin{multicols}{2}

Every error returned from a method call has an \emph{error name}, so
clients can know (generally) what went wrong without having to parse the
error message. Applications may define their own error names, or use one
of the standardized names listed in appendix~\ref{sec:standard-error-names}.

Error names have the same format as interface names, so the parser logic
can be reused.

\vfill

\columnbreak

:d DBus.Types
newtype ErrorName = ErrorName Text
	deriving (Eq, Ord, Show)

errorNameText :: ErrorName -> Text
errorNameText (ErrorName text) = text

errorName :: Text -> Maybe ErrorName
errorName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseInterfaceName text
	return (ErrorName text)

errorName_ :: Text -> ErrorName
errorName_ = tryParse "error name" errorName

instance Data.String.IsString ErrorName where
	fromString = errorName_ . Data.Text.pack

instance IsVariant ErrorName where
	toVariant = toVariant . errorNameText
	fromVariant v = fromVariant v >>= errorName
:

\end{multicols}

\clearpage
\subsubsection{Bus names}

\begin{multicols}{2}

Bus names are used when connecting to a central message dispatch bus. Every
connection is assigned a \emph{unique name}, such as {\tt :103.1}. This name
is usually used by the bus to send signals and method returns to client
applications.

Additionally, applications may request a \emph{well-known} name such as
{\tt org.freedesktop.DBus}. These are similar to internet hostnames; client
applications are written to send messages to this address, where they can be
served by whatever server happens to be running at the time.

\vfill

\columnbreak

:d DBus.Types
newtype BusName = BusName Text
	deriving (Eq, Ord, Show)

busNameText :: BusName -> Text
busNameText (BusName text) = text

busName :: Text -> Maybe BusName
busName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseBusName text
	return (BusName text)

busName_ :: Text -> BusName
busName_ = tryParse "bus name" busName

instance Data.String.IsString BusName where
	fromString = busName_ . Data.Text.pack

instance IsVariant BusName where
	toVariant = toVariant . busNameText
	fromVariant v = fromVariant v >>= busName
:

\end{multicols}

\begin{multicols}{2}

Unique names begin with {\tt `:'} and contain two or more elements, separated
by {\tt `.'}. Each element consists of characters from the set
{\tt [a-zA-Z0-9\_-]}.

Well-known names contain two or more elements, separated by {\tt `.'}. Each
element consists of characters from the set {\tt [a-zA-Z0-9\_-]}, and must
not start with a digit.

\vfill

\columnbreak

:d DBus.Types
parseBusName :: Parsec.Parser ()
parseBusName = name >> Parsec.eof where
	alpha = ['a'..'z'] ++ ['A'..'Z'] ++ "_-"
	alphanum = alpha ++ ['0'..'9']
	
	name = unique <|> wellKnown
	unique = do
		void (Parsec.char ':')
		elements alphanum
	
	wellKnown = elements alpha
	
	elements start = do
		element start
		Parsec.skipMany1 $ do
			void (Parsec.char '.')
			element start
	
	element start = do
		void (oneOf start)
		Parsec.skipMany (oneOf alphanum)
:

\end{multicols}

\clearpage
\subsection{Parsing signatures}

\begin{multicols}{2}

Signature parsing is the most common operation when unmarshaling messages;
therefore, an efficient parsing implementation is essential. However, I still
want the library's users to see a text-based interface to signatures.

Therefore, there are actually two signature parsing APIs -- one for other
modules in this library (especially {\tt DBus.Wire}, and a small wrapper for
users. The wrapper follows the pattern for other special strings, so users
can use string literals and so on.

\vfill

\columnbreak

:d DBus.Types
instance Data.String.IsString Signature where
	fromString = signature_ . Data.Text.pack

signature :: Text -> Maybe Signature
signature text = parseSignature bytes where
	bytes = Data.Text.Encoding.encodeUtf8 text

signature_ :: Text -> Signature
signature_ = tryParse "signature" signature
:

\end{multicols}

\begin{multicols}{2}

You know you're in for some shit when the parser requires two modules
named {\tt Unsafe}.

\vfill

\columnbreak

:d signature parsing imports
import qualified Data.ByteString as B
import qualified Data.ByteString.Unsafe as B
import qualified Foreign as F
import           System.IO.Unsafe (unsafePerformIO)
:

\end{multicols}

\begin{multicols}{2}

\noindent There are three special cases which can be optimized:

\begin{enumerate}
\item Empty signatures occur when messages have no body, and can use a constant
      result.
\item Single-character signatures occur when parsing variants, and can use a
      faster non-recursive parser.
\item All signatures larger than 255 characters are invalid, so they can be
      failed immediately.
\end{enumerate}
\vfill

\columnbreak

:d DBus.Types
parseSignature :: ByteString -> Maybe Signature
parseSignature bytes = case B.length bytes of
	0 -> Just (Signature [])
	1 -> parseSigFast bytes
	len | len <= 255 -> parseSigSlow bytes
	_ -> Nothing
:

\end{multicols}

\begin{multicols}{2}

Both parsers need to check whether a particular byte signifies an atom,
so that check is separated into a separate function.

\vfill

\columnbreak

:d DBus.Types
parseAtom :: Word8 -> (Type -> a) -> a -> a
parseAtom c yes no = case c of
	0x62 -> yes TypeBoolean
	0x6E -> yes TypeInt16
	0x69 -> yes TypeInt32
	0x78 -> yes TypeInt64
	0x79 -> yes TypeWord8
	0x71 -> yes TypeWord16
	0x75 -> yes TypeWord32
	0x74 -> yes TypeWord64
	0x64 -> yes TypeDouble
	0x73 -> yes TypeString
	0x67 -> yes TypeSignature
	0x6F -> yes TypeObjectPath
	_ -> no
:

\end{multicols}

\begin{multicols}{2}

None of the recursive container types can fit in one byte; if the
signature has only a single character, it must be either
{\tt [}\emph{atom}{\tt ]} or {\tt [TypeVariant]}.

This optimization is important when parsing variants, as they very often
contain signatures with only a single atomic type.

\vfill

\columnbreak

:d DBus.Types
parseSigFast :: ByteString -> Maybe Signature
parseSigFast bytes = parsed where
	parsed = parseAtom byte ok notAtom
	byte = B.unsafeHead bytes
	
	ok t = Just (Signature [t])
	notAtom = case byte of
		0x76 -> ok TypeVariant
		_ -> Nothing
:

\end{multicols}

\clearpage
\subsubsection{Full signature parser}

:d DBus.Types
parseSigSlow :: ByteString -> Maybe Signature
parseSigSlow bytes = unsafePerformIO io where
	io = B.unsafeUseAsCStringLen bytes castBuf
	castBuf (ptr, len) = parseSigBuf (F.castPtr ptr, len)

parseSigBuf :: (F.Ptr Word8, Int) -> IO (Maybe Signature)
parseSigBuf (buf, len) = mainLoop [] 0 where
	|full signature parser|
:

:d full signature parser
mainLoop acc ii | ii >= len = return . Just . Signature $ reverse acc
mainLoop acc ii = do
	c <- F.peekElemOff buf ii
	let next t = mainLoop (t : acc) (ii + 1)
	parseAtom c next $ case c of
		0x76 -> next TypeVariant
		
		-- '('
		0x28 -> do
			mt <- structure (ii + 1)
			case mt of
				Just (ii', t) -> mainLoop (t : acc) ii'
				Nothing -> return Nothing
		
		-- 'a'
		0x61 -> do
			mt <- array (ii + 1)
			case mt of
				Just (ii', t) -> mainLoop (t : acc) ii'
				Nothing -> return Nothing
		
		_ -> return Nothing
:

:d full signature parser
structure :: Int -> IO (Maybe (Int, Type))
structure = loop [] where
	loop _ ii | ii >= len = return Nothing
	loop acc ii = do
		c <- F.peekElemOff buf ii
		let next t = loop (t : acc) (ii + 1)
		parseAtom c next $ case c of
			0x76 -> next TypeVariant
			
			-- '('
			0x28 -> do
				mt <- structure (ii + 1)
				case mt of
					Just (ii', t) -> loop (t : acc) ii'
					Nothing -> return Nothing
			
			-- ')'
			0x29 -> return $ case acc of
				[] -> Nothing
				_ -> Just $ (ii + 1, TypeStructure (reverse acc))
			
			-- 'a'
			0x61 -> do
				mt <- array (ii + 1)
				case mt of
					Just (ii', t) -> loop (t : acc) ii'
					Nothing -> return Nothing
			
			_ -> return Nothing
:

:d full signature parser
array :: Int -> IO (Maybe (Int, Type))
array ii | ii >= len = return Nothing
array ii = do
	c <- F.peekElemOff buf ii
	let next t = return $ Just (ii + 1, TypeArray t)
	parseAtom c next $ case c of
		0x76 -> next TypeVariant
		
		-- '('
		0x28 -> do
			mt <- structure (ii + 1)
			case mt of
				Just (ii', t) -> return $ Just (ii', TypeArray t)
				Nothing -> return Nothing
		
		-- '{'
		0x7B -> dict (ii + 1)
		
		-- 'a'
		0x61 -> do
			mt <- array (ii + 1)
			case mt of
				Just (ii', t) -> return $ Just (ii', TypeArray t)
				Nothing -> return Nothing
		
		_ -> return Nothing
:

:d full signature parser
dict :: Int -> IO (Maybe (Int, Type))
dict ii | ii + 1 >= len = return Nothing
dict ii = do
	c1 <- F.peekElemOff buf ii
	c2 <- F.peekElemOff buf (ii + 1)
	
	let mt1 = parseAtom c1 Just Nothing
	
	let next t = return $ Just (ii + 2, t)
	mt2 <- parseAtom c2 next $ case c2 of
		0x76 -> next TypeVariant
		
		-- '('
		0x28 -> structure (ii + 2)
		
		-- 'a'
		0x61 -> array (ii + 2)
		
		_ -> return Nothing
	
	case mt2 of
		Nothing -> return Nothing
		Just (ii', t2) -> if ii' >= len
			then return Nothing
			else do
				c3 <- F.peekElemOff buf ii'
				return $ do
					if c3 == 0x7D then Just () else Nothing
					t1 <- mt1
					Just (ii' + 1, TypeDictionary t1 t2)
:

\clearpage
\subsection{Container boxes}

:d DBus.Types
newtype Structure = Structure [Value]

instance IsVariant Structure where
	toVariant (Structure xs) = Variant (ValueStructure xs)
	fromVariant (Variant (ValueStructure xs)) = Just (Structure xs)
	fromVariant _ = Nothing

structureItems :: Structure -> [Variant]
structureItems (Structure xs) = map Variant xs
:

:d DBus.Types
data Array = Array Type (Vector Value)

instance IsVariant Array where
	toVariant (Array t xs) = Variant (ValueVector t xs)
	fromVariant (Variant (ValueVector t xs)) = Just (Array t xs)
	fromVariant _ = Nothing

arrayItems :: Array -> [Variant]
arrayItems (Array _ xs) = map Variant (Data.Vector.toList xs)
:

:d DBus.Types
data Dictionary = Dictionary Type (Map Atom Value)

instance IsVariant Dictionary where
	toVariant (Dictionary t xs) = Variant (ValueMap t xs)
	fromVariant (Variant (ValueMap t xs)) = Just (Dictionary t xs)
	fromVariant _ = Nothing

dictionaryItems :: Dictionary -> [(Variant, Variant)]
dictionaryItems (Dictionary _ xs) = do
	(k, v) <- Data.Map.toList xs
	return (Variant (ValueAtom k), Variant v)
:
