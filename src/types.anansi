:# Copyright (C) 2009-2011 John Millikin <jmillikin@gmail.com>
:# 
:# This program is free software: you can redistribute it and/or modify
:# it under the terms of the GNU General Public License as published by
:# the Free Software Foundation, either version 3 of the License, or
:# any later version.
:# 
:# This program is distributed in the hope that it will be useful,
:# but WITHOUT ANY WARRANTY; without even the implied warranty of
:# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
:# GNU General Public License for more details.
:# 
:# You should have received a copy of the GNU General Public License
:# along with this program.  If not, see <http://www.gnu.org/licenses/>.

\section{Values and types}

\dbus{} values are divided into two categories, \emph{atoms} and
\emph{containers}. Atoms are strings, numbers, and so on. Containers can
store other values, including other containers. Generally, values act like
their Haskell equivalents, with one important exception: \dbus{} dictionaries
only support atomic keys. Every \dbus{} type has a \emph{type code}, a short
string describing what sort of data the value stores.

\begin{table}[h]
\label{tab:dbus-types}
\caption{\dbus{} Types}
\begin{center}
\begin{tabular}{llll}
\toprule
\dbus{} Type  & Code    & Description & Haskell Type \\
\midrule
Boolean     & {\tt b} & {\tt True} or {\tt False} & {\tt Bool} \\
Byte        & {\tt y} & 8-bit unsigned integer & {\tt Word8} \\
Int16       & {\tt n} & 16-bit signed integer & {\tt Int16} \\
UInt16      & {\tt q} & 16-bit unsigned integer & {\tt Word16} \\
Int32       & {\tt i} & 32-bit signed integer & {\tt Int32} \\
UInt32      & {\tt u} & 32-bit unsigned integer & {\tt Word32} \\
Int64       & {\tt x} & 64-bit signed integer & {\tt Int64} \\
UInt64      & {\tt t} & 64-bit unsigned integer & {\tt Word64} \\
Double      & {\tt d} & 64-bit IEEE754 floating-point & {\tt Double} \\
String      & {\tt s} & Unicode text & {\tt Text} \\
Object Path & {\tt o} & \dbus{} remote object path & {\tt DBus.Types.ObjectPath} \\
Signature   & {\tt g} & List of \dbus{} types & {\tt DBus.Types.Signature} \\
Variant     & {\tt v} & Can contain any \dbus{} value & {\tt DBus.Types.Variant} \\
Array       & {\tt a}\emph{t} & Homogenous list of \emph{t} & {\tt Vector} \\
Dictionary  & {\tt a\{}\emph{k}\emph{t}{\tt \}} & Associative map of \emph{k} to \emph{t} & {\tt Map} \\
Structure   & {\tt (}\emph{codes}{\tt )} & Heterogeneous list of \dbus{} values & Tuples \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

\begin{multicols}{2}

Since the set of types is fixed, they are internally stored as an enumeration,
named {\tt Type}. The names mostly match the \dbus{} names, but a few have
been slightly changed to conform with Haskell naming conventions.

\vfill

\columnbreak

:d DBus.Types
data Type
	= TypeBoolean
	| TypeWord8
	| TypeWord16
	| TypeWord32
	| TypeWord64
	| TypeInt16
	| TypeInt32
	| TypeInt64
	| TypeDouble
	| TypeString
	| TypeSignature
	| TypeObjectPath
	| TypeVariant
	| TypeArray Type
	| TypeDictionary Type Type
	| TypeStructure [Type]
	deriving (Eq, Ord)
:

\end{multicols}

\clearpage
\subsection{Type signatures}

\begin{multicols}{2}

A list of types is called a \emph{signature}. Signatures are traditionally
represented as a string of type codes, such as {\tt "a\{sas\}"} for
{\tt Map String [String]}. However, this library stores signatures as
{\tt [Type]} to take advantage of Haskell's strong typing.

\vfill

\columnbreak

:d DBus.Types
newtype Signature = Signature [Type]
	deriving (Eq, Ord)

signatureTypes :: Signature -> [Type]
signatureTypes (Signature types) = types
:

\end{multicols}

\begin{multicols}{2}

Although signatures are strongly-typed internally, they are exposed to the
user as if they're special strings matching the \dbus{} signature format.

\vfill

\columnbreak

:d DBus.Types
instance Show Signature where
	showsPrec d sig = showParen (d > 10) $
		showString "Signature " .
		shows (signatureText sig)
:

\end{multicols}

:d DBus.Types
signatureText :: Signature -> Text
signatureText (Signature ts) = Data.Text.pack (concatMap typeCode ts)
:

\begin{multicols}{2}

:d DBus.Types
typeCode :: Type -> String
typeCode TypeBoolean    = "b"
typeCode TypeWord8      = "y"
typeCode TypeWord16     = "q"
typeCode TypeWord32     = "u"
typeCode TypeWord64     = "t"
typeCode TypeInt16      = "n"
typeCode TypeInt32      = "i"
typeCode TypeInt64      = "x"
typeCode TypeDouble     = "d"
typeCode TypeString     = "s"
typeCode TypeSignature  = "g"
typeCode TypeObjectPath = "o"
typeCode TypeVariant    = "v"
typeCode (TypeArray t)  = 'a' : typeCode t
typeCode (TypeDictionary kt vt) = concat ["a{", typeCode kt, typeCode vt, "}"]
typeCode (TypeStructure ts) = '(' : (concatMap typeCode ts ++ ")")
:

\columnbreak

~

~

{\tt typeCode} is a straightforward translation of table~\ref{tab:dbus-types}.
Users (and other modules in this library) will not call it directly; they
should use {\tt signatureString} instead.

\vfill

\end{multicols}

\clearpage
\subsection{Generic value boxing}

\begin{multicols}{2}

The \dbus{} type system has a few features, such as structures and
variants, that require some way to store \dbus{} values of different types
in the same container. The Haskell type system does not support this; as a
workaround, all values supported by \dbus{} can be type-safely stored in the
generic box {\tt Value}. Atomic values are stored in {\tt Atom}, so they can
be used as map keys in {\tt ValueMap}.

It is possible to make this slightly less verbose by using existential
types, but the additional indirection causes slower message parsing.

\vfill

\columnbreak

:d DBus.Types
data Value
	= ValueAtom Atom
	| ValueVariant Variant
	| ValueVector Type (Vector Value)
	| ValueMap Type (Map Atom Value)
	| ValueStructure [Value]
	deriving (Eq)

data Atom
	= AtomBool Bool
	| AtomWord8 Word8
	| AtomWord16 Word16
	| AtomWord32 Word32
	| AtomWord64 Word64
	| AtomInt16 Int16
	| AtomInt32 Int32
	| AtomInt64 Int64
	| AtomDouble Double
	| AtomText Text
	| AtomSignature Signature
	| AtomObjectPath ObjectPath
	deriving (Eq, Ord)
:

\end{multicols}

\begin{multicols}{2}

The {\tt IsValue} class exposes an interface common to all values supported
by \dbus{}. Every value has a {\tt Type}, and can be converted to/from a
{\tt Value}.

\vfill

\columnbreak

:d DBus.Types
class IsValue a where
	typeOf :: a -> Type
	toValue :: a -> Value
	fromValue :: Value -> Maybe a
:

\end{multicols}

\begin{multicols}{2}

The {\tt IsAtom} class is not strictly necessary, but it allows
users to construct dictionaries without an intermediate type validation.

\vfill

\columnbreak

:d DBus.Types
class IsValue a => IsAtom a where
	toAtom :: a -> Atom
	fromAtom :: Atom -> Maybe a
:

\end{multicols}

\subsubsection{Variants}

\begin{multicols}{2}

The {\tt toValue} function has an important invariant: values of a given
Haskell type must always be converted to the same \dbus{} type. If this
invariant is broken, homogenous containers (arrays and dictionaries) with
invalid contents can be sent over the wire. To protect {\tt toValue}, it
is not exported to library users.

However, users often want to define and work directly with their own types.
As a workaround, the {\tt IsVariant} class allows limited extension to the
supported types. The only significant restriction is that the contents of
homogenous containers must instance {\tt IsValue}.

\vfill

\columnbreak

:d DBus.Types
newtype Variant = Variant Value
	deriving (Eq)

class IsVariant a where
	toVariant :: a -> Variant
	fromVariant :: Variant -> Maybe a
:

\end{multicols}

\clearpage
\subsubsection{Inspecting boxed values}

If a user is interacting with the library through an REPL (e.g. GHCI), they
might want to print the content of a variant -- for example, to print messages
received from the bus. Due to the various wrappers between {\tt Variant} and
the actual data, this is somewhat complex.

\begin{multicols}{2}

\begin{quote}
:d DBus.Types
showAtom :: Atom -> String
showAtom (AtomBool x) = show x
showAtom (AtomWord8 x) = show x
showAtom (AtomWord16 x) = show x
showAtom (AtomWord32 x) = show x
showAtom (AtomWord64 x) = show x
showAtom (AtomInt16 x) = show x
showAtom (AtomInt32 x) = show x
showAtom (AtomInt64 x) = show x
showAtom (AtomDouble x) = show x
showAtom (AtomText x) = show x
showAtom (AtomSignature x) = show x
showAtom (AtomObjectPath x) = show x

showValue :: Value -> String
showValue (ValueAtom x) = showAtom x
showValue (ValueVariant x) = show x
showValue (ValueVector _ xs) = showThings "[" showValue "]" (Data.Vector.toList xs)
showValue (ValueMap _ xs) = showThings "{" showPair "}" (Data.Map.toList xs) where
	showPair (k, v) = showAtom k ++ ": " ++ showValue v
showValue (ValueStructure xs) = showThings "(" showValue ")" xs

showThings :: String -> (a -> String) -> String -> [a] -> String
showThings a s z xs = a ++ intercalate ", " (map s xs) ++ z
:
\end{quote}

\columnbreak

Printing {\tt Atom}s is easy; all atomic types have obvious formats, and
are supported natively by Haskell.

{\tt Value}s are a bit harder. Even if I wanted to add {\tt Show} instances
directly to {\tt Value} and {\tt Atom}, they wouldn't be suitable because
{\tt Vector} and {\tt Map} have truly bizarre {\tt Show} instances:

\begin{quote}
\begin{verbatim}
ghci> Data.Vector.singleton "foo"
fromList ["foo"] :: Data.Vector.Vector

ghci> Data.Map.singleton "foo" "bar"
fromList [("foo","bar")]
\end{verbatim}
\end{quote}

\noindent Therefore, {\tt showValue} does its own container formatting.

\vfill

\end{multicols}

To preserve the variant-based public interface, {\tt showAtom} and
{\tt showUser} are not exported to the user. This preserves the
appearance that {\tt Variant} is a simple wrapping box.

\begin{quote}
:d DBus.Types
instance Show Variant where
	showsPrec d (Variant x) = showParen (d > 10) $
		showString "Variant " .  showString (showValue x)
:
\end{quote}

\clearpage
\subsubsection{Inspecting boxed types}

Printing a {\tt Variant} lets the user see what value it contains, but
sometimes they need to know exactly what type \dbus{} thinks it is. This
is particularly important when working with integers, as some APIs will
only accept integers of a particular size.

\begin{multicols}{2}

:d DBus.Types
variantType :: Variant -> Type
variantType (Variant val) = valueType val

valueType :: Value -> Type
valueType (ValueAtom x) = atomType x
valueType (ValueVariant _) = TypeVariant
valueType (ValueVector t _) = t
valueType (ValueMap t _) = t
valueType (ValueStructure vs) = TypeStructure (map valueType vs)

atomType :: Atom -> Type
atomType (AtomBool _) = TypeBoolean
atomType (AtomWord8 _) = TypeWord8
atomType (AtomWord16 _) = TypeWord16
atomType (AtomWord32 _) = TypeWord32
atomType (AtomWord64 _) = TypeWord64
atomType (AtomInt16 _) = TypeInt16
atomType (AtomInt32 _) = TypeInt32
atomType (AtomInt64 _) = TypeInt64
atomType (AtomDouble _) = TypeDouble
atomType (AtomText _) = TypeString
atomType (AtomSignature _) = TypeSignature
atomType (AtomObjectPath _) = TypeObjectPath
:

\columnbreak

All of {\tt Atom}'s constructors map directly to a {\tt Type}, so
implementing {\tt atomType} is trivial.

{\tt ValueVector} and {\tt ValueMap} require special handling. \dbus{} needs
to know their full type even if they're empty, but {\tt ([] :: [Value])}
contains no information about its contents. As a workaround, the full type
of the container is stored in the box itself at construction.

\end{multicols}

\begin{multicols}{2}

:d DBus.Types
instance Show Type where
	showsPrec d x = case x of
		TypeBoolean -> showString "Bool"
		TypeWord8 -> showString "Word8"
		TypeWord16 -> showString "Word16"
		TypeWord32 -> showString "Word32"
		TypeWord64 -> showString "Word64"
		TypeInt16 -> showString "Int16"
		TypeInt32 -> showString "Int32"
		TypeInt64 -> showString "Int64"
		TypeDouble -> showString "Double"
		TypeString -> showString "String"
		TypeSignature -> showString "Signature"
		TypeObjectPath -> showString "ObjectPath"
		TypeVariant -> showString "Variant"
		TypeArray t -> showString "[" . shows t . showString "]"
		TypeDictionary kt vt -> showParen (d > 10) $
			showString "Map " .  shows kt .  showString " " .  showsPrec 11 vt
		TypeStructure types -> showString (showThings "(" show ")" types)
:

\columnbreak

I have two choices when deciding how to show {\tt Type}s; can use type
codes, as in signatures, or try to generate a more Haskell-ish format. I
chose the second option because it's easier to read; for example, compare
{\tt "a\{sas\}"} and {\tt Map String [String]}. This is particularly
important when working with complex or deeply-nested structures, which are
common in some APIs.

Note that the types displayed here do not match up exactly to the actual
Haskell types used to implement the boxes. I don't want typical users to
care about how the internals work.

\vfill

\end{multicols}

\clearpage
\subsection{Special string types}

Various aspects of \dbus{} require the use of specially-formatted strings. Every
special string type gets its own Haskell type and construction function; this
allows the library to assume all such strings are correctly formatted. The
constructors will evaluate to {\tt Nothing} if their input is invalid. In
addition, partial versions (suffixed with {\tt \_}) are available for users
who don't care about validation; these will throw an exception if the input
is invalid. Finally, {\tt IsString} instances are available for all special
strings, so users can just enable {\tt OverloadedStrings} and use string
literals directly.

Validation is performed using Parsec. Unfortunately, Parsec does not work
with packed strings; I'll define a few utility functions first, so the
validation logic is more obvious. Note that these discard the Parsec error
message; if some input doesn't match, the exact error is unlikely to be
interesting.

:d text validation imports
import qualified Text.ParserCombinators.Parsec as Parsec
import           Text.ParserCombinators.Parsec ((<|>), oneOf)
:

:d text validation
skipSepBy1 :: Parsec.Parser a -> Parsec.Parser b -> Parsec.Parser ()
skipSepBy1 p sep = do
	void p
	Parsec.skipMany (sep >> p)

runParser :: Parsec.Parser a -> Text -> Maybe ()
runParser parser text = case Parsec.parse parser "" (Data.Text.unpack text) of
	Left _ -> Nothing
	Right _ -> Just ()
:

\clearpage
\subsubsection{Object paths}

\begin{multicols}{2}

\dbus{} is an object-oriented protocol; most \dbus{} sessions consist of method
calls sent to \emph{objects} exported by other applications. An objects is
identified by a \emph{object path}, such as {\tt /org/freedesktop/DBus}, which
is unique within each application.

\vfill

\columnbreak

:d DBus.Types
newtype ObjectPath = ObjectPath Text
	deriving (Eq, Ord, Show)

objectPathText :: ObjectPath -> Text
objectPathText (ObjectPath text) = text
:

\end{multicols}

\begin{multicols}{2}

An object path may be one of

\begin{itemize}
\item The root path, {\tt "/"}.
\item {\tt '/'}, followed by one or more elements, separated by {\tt '/'}.
      Each element contains characters in the set {\tt [a-zA-Z0-9\_]}, and
      must have at least one character.
\end{itemize}

Element names are separated by {\tt '/'}, and the path may not end in
{\tt '/'} unless it is the root path.

\vfill

\columnbreak

:d DBus.Types
parseObjectPath :: Parsec.Parser ()
parseObjectPath = root <|> object where
	root = Parsec.try $ do
		slash
		Parsec.eof
	
	object = do
		slash
		skipSepBy1 element slash
	
	element = Parsec.skipMany1 (oneOf chars)
	
	slash = void (Parsec.char '/')
	chars = concat [ ['a'..'z']
	               , ['A'..'Z']
	               , ['0'..'9']
	               , "_"]
:

\end{multicols}

:d DBus.Types
instance Data.String.IsString ObjectPath where
	fromString = objectPath_ . Data.Text.pack

objectPath :: Text -> Maybe ObjectPath
objectPath text = do
	runParser parseObjectPath text
	return (ObjectPath text)

objectPath_ :: Text -> ObjectPath
objectPath_ text = case objectPath text of
	Just x -> x
	Nothing -> error ("Invalid object path: " ++ show text)
:

\clearpage
\subsubsection{Interface names}

\begin{multicols}{2}

Each object may have several \emph{interfaces}, each identified by an
\emph{interface name}. Interfaces are the basic units of \dbus{} APIs, and
even simple objects are expected to contain several (such as
{\tt org.freedesktop.DBus.Introspectable} or
{\tt org.freedesktop.DBus.Properties}). They correspond generally to Haskell
classes, or Python protocols.

\vfill

\columnbreak

:d DBus.Types
newtype InterfaceName = InterfaceName Text
	deriving (Eq, Ord, Show)

interfaceNameText :: InterfaceName -> Text
interfaceNameText (InterfaceName text) = text
:

\end{multicols}

\begin{multicols}{2}

An interface name consists of two or more {\tt '.'}-separated elements. Each
element constists of characters from the set {\tt [a-zA-Z0-9\_]}, may not
start with a digit, and must have at least one character.

\vfill

\columnbreak

:d DBus.Types
parseInterfaceName :: Parsec.Parser ()
parseInterfaceName = name >> Parsec.eof where
	alpha = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
	alphanum = alpha ++ ['0'..'9']
	element = do
		void (oneOf alpha)
		Parsec.skipMany (oneOf alphanum)
	name = do
		element
		void (Parsec.char '.')
		skipSepBy1 element (Parsec.char '.')
:

\end{multicols}

:d DBus.Types
instance Data.String.IsString InterfaceName where
	fromString = interfaceName_ . Data.Text.pack

interfaceName :: Text -> Maybe InterfaceName
interfaceName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseInterfaceName text
	return (InterfaceName text)

interfaceName_ :: Text -> InterfaceName
interfaceName_ text = case interfaceName text of
	Just x -> x
	Nothing -> error ("Invalid interface name: " ++ show text)
:

\clearpage
\subsubsection{Member names}

\begin{multicols}{2}

An interface, in turn, contains several \emph{members}, each identified by a
\emph{member name} such as {\tt Introspect}. A member might be either a
\emph{method}, which clients can call, or a \emph{signal}, which clients can
wait for.

\vfill

\columnbreak

:d DBus.Types
newtype MemberName = MemberName Text
	deriving (Eq, Ord, Show)

memberNameText :: MemberName -> Text
memberNameText (MemberName text) = text
:

\end{multicols}

\begin{multicols}{2}

Member names must contain only characters from the set {\tt [a-zA-Z0-9\_]},
may not begin with a digit, and must be at least one character long.

\vfill

\columnbreak

:d DBus.Types
parseMemberName :: Parsec.Parser ()
parseMemberName = name >> Parsec.eof where
	alpha = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
	alphanum = alpha ++ ['0'..'9']
	name = do
		void (oneOf alpha)
		Parsec.skipMany (oneOf alphanum)
:

\end{multicols}

:d DBus.Types
instance Data.String.IsString MemberName where
	fromString = memberName_ . Data.Text.pack

memberName :: Text -> Maybe MemberName
memberName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseMemberName text
	return (MemberName text)

memberName_ :: Text -> MemberName
memberName_ text = case memberName text of
	Just x -> x
	Nothing -> error ("Invalid member name: " ++ show text)
:

\clearpage
\subsubsection{Error names}

\begin{multicols}{2}

Every error returned from a method call has an \emph{error name}, so
clients can know (generally) what went wrong without having to parse the
error message. Applications may define their own error names, or use one
of the standardized names listed in appendix~\ref{sec:standard-error-names}.

Error names have the same format as interface names, so the parser logic
can be reused.

\vfill

\columnbreak

:d DBus.Types
newtype ErrorName = ErrorName Text
	deriving (Eq, Ord, Show)

errorNameText :: ErrorName -> Text
errorNameText (ErrorName text) = text
:

\end{multicols}

:d DBus.Types
instance Data.String.IsString ErrorName where
	fromString = errorName_ . Data.Text.pack

errorName :: Text -> Maybe ErrorName
errorName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseInterfaceName text
	return (ErrorName text)

errorName_ :: Text -> ErrorName
errorName_ text = case errorName text of
	Just x -> x
	Nothing -> error ("Invalid error name: " ++ show text)
:

\clearpage
\subsubsection{Bus names}

\begin{multicols}{2}

Bus names are used when connecting to a central message dispatch bus. Every
connection is assigned a \emph{unique name}, such as {\tt :103.1}. This name
is usually used by the bus to send signals and method returns to client
applications.

Additionally, applications may request a \emph{well-known} name such as
{\tt org.freedesktop.DBus}. These are similar to internet hostnames; client
applications are written to send messages to this address, where they can be
served by whatever server happens to be running at the time.

\vfill

\columnbreak

:d DBus.Types
newtype BusName = BusName Text
	deriving (Eq, Ord, Show)

busNameText :: BusName -> Text
busNameText (BusName text) = text
:

\end{multicols}

\begin{multicols}{2}

Unique names begin with {\tt `:'} and contain two or more elements, separated
by {\tt `.'}. Each element consists of characters from the set
{\tt [a-zA-Z0-9\_-]}.

Well-known names contain two or more elements, separated by {\tt `.'}. Each
element consists of characters from the set {\tt [a-zA-Z0-9\_-]}, and must
not start with a digit.

\vfill

\columnbreak

:d DBus.Types
parseBusName :: Parsec.Parser ()
parseBusName = name >> Parsec.eof where
	alpha = ['a'..'z'] ++ ['A'..'Z'] ++ "_-"
	alphanum = alpha ++ ['0'..'9']
	
	name = unique <|> wellKnown
	unique = do
		void (Parsec.char ':')
		elements alphanum
	
	wellKnown = elements alpha
	
	elements start = do
		element start
		Parsec.skipMany1 $ do
			void (Parsec.char '.')
			element start
	
	element start = do
		void (oneOf start)
		Parsec.skipMany (oneOf alphanum)
:

\end{multicols}

:d DBus.Types
instance Data.String.IsString BusName where
	fromString = busName_ . Data.Text.pack

busName :: Text -> Maybe BusName
busName text = do
	when (Data.Text.length text > 255) Nothing
	runParser parseBusName text
	return (BusName text)

busName_ :: Text -> BusName
busName_ text = case busName text of
	Just x -> x
	Nothing -> error ("Invalid bus name: " ++ show text)
:
