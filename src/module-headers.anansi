:# Copyright (C) 2009-2011 John Millikin <jmillikin@gmail.com>
:# 
:# This program is free software: you can redistribute it and/or modify
:# it under the terms of the GNU General Public License as published by
:# the Free Software Foundation, either version 3 of the License, or
:# any later version.
:# 
:# This program is distributed in the hope that it will be useful,
:# but WITHOUT ANY WARRANTY; without even the implied warranty of
:# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
:# GNU General Public License for more details.
:# 
:# You should have received a copy of the GNU General Public License
:# along with this program.  If not, see <http://www.gnu.org/licenses/>.

\section{Module headers}

:f DBus/Types.hs
|copyright|
module DBus.Types
	( Type(..)
	
	, Signature
	, signature
	, signature_
	, signatureText
	, signatureTypes
	
	, IsValue
	, IsAtom
	, Variant
	
	, IsVariant(..)
	, variantType
	
	, ObjectPath
	, objectPath
	, objectPath_
	, objectPathText
	
	, InterfaceName
	, interfaceName
	, interfaceName_
	, interfaceNameText
	
	, MemberName
	, memberName
	, memberName_
	, memberNameText
	
	, ErrorName
	, errorName
	, errorName_
	, errorNameText
	
	, BusName
	, busName
	, busName_
	, busNameText
	
	, Structure
	, Array
	, Dictionary
	, structureItems
	, arrayItems
	, dictionaryItems
	) where
import DBus.Types.Internal
:

:f DBus/Types/Internal.hs
|copyright|
module DBus.Types.Internal where
import           Control.Monad (when)
import           Data.ByteString (ByteString)
import qualified Data.ByteString.Char8
import           Data.Int
import           Data.List (intercalate)
import qualified Data.Map
import           Data.Map (Map)
import qualified Data.String
import qualified Data.Text
import           Data.Text (Text)
import qualified Data.Text.Encoding
import qualified Data.Text.Lazy
import qualified Data.Vector
import           Data.Vector (Vector)
import           Data.Word
|text validation imports|
|signature parsing imports|

import           DBus.Util (void)

|DBus.Types|
|text validation|
:

:f DBus/Message.hs
|copyright|
module DBus.Message
	( Message ( messageFlags
	          , messageBody
	          )
	, Flag (..)
	, Serial
	, serialValue
	, Unknown (..)
	, MethodCall (..)
	, MethodReturn (..)
	, Error (..)
	, errorMessage
	, Signal (..)
	, ReceivedMessage (..)
	, receivedSerial
	, receivedSender
	, receivedBody
	) where
import DBus.Message.Internal
:

:f DBus/Message/Internal.hs
{-# LANGUAGE OverloadedStrings #-}
|copyright|
module DBus.Message.Internal where
import           Data.Maybe (fromMaybe)
import qualified Data.Set
import           Data.Set (Set)
import qualified Data.Text
import           Data.Text (Text)
import           Data.Word (Word8, Word32)

import           DBus.Types hiding (errorName)
import           DBus.Util (maybeIndex)

|DBus.Message|
:

:f DBus/Wire.hs
|copyright|
module DBus.Wire
	( Endianness (..)
	, MarshalError
	, UnmarshalError
	, marshalMessage
	, unmarshalMessage
	) where
import DBus.Wire.Internal
:

:f DBus/Wire/Internal.hs
{-# LANGUAGE OverloadedStrings #-}
|copyright|
module DBus.Wire.Internal where
import Control.Monad (liftM, when, unless)

import qualified Data.Binary.Builder
import qualified Data.Binary.Get
import           Data.Binary.Put (runPut)
import           Data.Bits ((.&.), (.|.))
import qualified Data.ByteString
import           Data.ByteString (ByteString)
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Lazy
import           Data.Int (Int16, Int32, Int64)
import qualified Data.Map
import           Data.Map (Map)
import           Data.Maybe (fromJust, listToMaybe, fromMaybe)
import qualified Data.Set
import           Data.Set (Set)
import qualified Data.Text
import           Data.Text (Text)
import qualified Data.Text.Encoding
import qualified Data.Vector
import           Data.Vector (Vector)
import           Data.Word (Word8, Word16, Word32, Word64)

import qualified Data.Binary.IEEE754

import           DBus.Message.Internal
import           DBus.Types.Internal
import           DBus.Wire.Unicode (maybeDecodeUtf8)
import           DBus.Util (void, untilM)
import qualified DBus.Util.MonadError as E

|DBus.Wire|
:

:f DBus/Wire/Unicode.hs
|copyright|
module DBus.Wire.Unicode
	( maybeDecodeUtf8
	) where
import Data.ByteString (ByteString)
import Data.Text (Text)
import Data.Text.Encoding (decodeUtf8)
import Data.Text.Encoding.Error (UnicodeException)
import qualified Control.Exception as Exc
import System.IO.Unsafe (unsafePerformIO)
|DBus.Wire.Unicode|
:

:f DBus/Address.hs
{-# LANGUAGE OverloadedStrings #-}
|copyright|
module DBus.Address
	( Address
	, addressMethod
	, addressParameters
	, address
	, addresses
	, addressText
	
	-- * Environmental addresses
	, getSystem
	, getSession
	, getStarter
	) where
import qualified Control.Exception
import           Data.Char (ord, chr)
import qualified Data.Map
import           Data.Map (Map)
import qualified Data.Text
import           Data.Text (Text)
import qualified System.Environment
import           Text.Printf (printf)
import           Text.ParserCombinators.Parsec hiding (runParser)

import           DBus.Util (hexToInt, void)
import           DBus.Types.Internal (runParser)
|DBus.Address|
:

:f DBus/Connection.hs
{-# LANGUAGE OverloadedStrings #-}
|copyright|
module DBus.Connection
	( Connection
	, ConnectionError
	, connect
	, disconnect
	, send
	, receive
	
	-- * Authentication
	, Mechanism(..)
	, mechanism
	, external
	
	-- * Transports
	, Transport
	, Socket
	, transport
	, socket
	, socketPut
	, socketGet
	
	, unix
	, tcp
	) where
import           Control.Concurrent
import           Control.Monad (when)
import qualified Data.ByteString
import qualified Data.ByteString.Lazy
import           Data.IORef

import           DBus.Address
import           DBus.Connection.Authentication
import           DBus.Connection.Error
import           DBus.Connection.Transport
import           DBus.Message.Internal
import           DBus.Wire

|DBus.Connection|
:

:f DBus/Connection/Authentication.hs
|copyright|
module DBus.Connection.Authentication
	( Mechanism
	, mechanism
	, authenticate
	, external
	) where

import           Prelude hiding (getLine, head)
import           Control.Monad (liftM)
import qualified Data.ByteString
import qualified Data.ByteString.Char8
import           Data.Char (ord)
import qualified System.Posix.User
import           Text.Printf (printf)

import           DBus.Connection.Transport
import           DBus.Util (readUntil, dropEnd)

|DBus.Connection.Authentication|
:

:f DBus/Connection/Error.hs
{-# LANGUAGE DeriveDataTypeable #-}
|copyright|
module DBus.Connection.Error where
import           Control.Exception (Exception, throwIO)
import           Data.Typeable (Typeable)
|DBus.Connection.Error|
:

:f DBus/Connection/Transport.hs
{-# LANGUAGE OverloadedStrings #-}
|copyright|
module DBus.Connection.Transport
	( Transport
	, transport
	, Socket
	, socket
	, socketPut
	, socketGet
	, socketClose
	, tcp
	, unix
	, connectTransport
	) where

import qualified Control.Exception
import           Control.Monad (unless)
import qualified Data.Binary.Get
import qualified Data.Binary.Put
import qualified Data.ByteString
import           Data.ByteString (ByteString)
import qualified Data.Map
import qualified Data.Text
import           Data.Text (Text)
import           Data.Word (Word32)
import qualified Network
import qualified Network.Socket
import qualified System.IO
import           Text.ParserCombinators.Parsec

import           DBus.Address
import           DBus.Connection.Error

|DBus.Connection.Transport|
:

:f DBus/Client.hs
|copyright|
module DBus.Client
	( Client
	, connect
	, attach
	, disconnect
	, call
	, call_
	, listen
	, setMessageProcessor
	) where
import           DBus.Client.Internal
:

:f DBus/Client/Internal.hs
{-# LANGUAGE OverloadedStrings #-}
|copyright|
module DBus.Client.Internal where
import           Control.Concurrent
import           Control.Monad (forever, unless)
import           Control.Monad.Fix (mfix)
import           Data.IORef
import qualified Data.Map
import           Data.Map (Map)
import           Data.Maybe (isJust)
import qualified Data.Text
import qualified Data.Set

import           DBus.Address
import qualified DBus.Connection
import           DBus.Connection (Connection)
import           DBus.Connection.Authentication (external)
import           DBus.Connection.Transport (unix, tcp)
import           DBus.Connection.Error
import qualified DBus.MatchRule
import           DBus.Message
import           DBus.Types (BusName)
import           DBus.Util (void)

|DBus.Client|
:

:f DBus/Client/Simple.hs
{-# LANGUAGE OverloadedStrings #-}
|copyright|
module DBus.Client.Simple
	(
	-- * Clients
	  Client
	, connectSystem
	, connectSession
	, connectStarter
	, disconnect
	
	-- ** Proxies
	, Proxy
	, proxy
	, call
	, DBus.Client.Simple.listen
	
	-- * Name reservation
	, RequestNameFlag(..)
	, RequestNameReply(..)
	, ReleaseNameReply(..)
	, requestName
	, releaseName
	
	-- * Types
	
	-- ** Variants
	, Variant
	, IsVariant(..)
	, IsValue
	, IsAtom
	
	-- ** Signatures
	, Signature
	, signature
	, signature_
	, signatureText
	
	-- ** Object paths
	, ObjectPath
	, objectPath
	, objectPath_
	, objectPathText
	
	-- ** Interface names
	, InterfaceName
	, interfaceName
	, interfaceName_
	, interfaceNameText
	
	-- ** Member names
	, MemberName
	, memberName
	, memberName_
	, memberNameText
	
	-- ** Error names
	, ErrorName
	, errorName
	, errorName_
	, errorNameText
	
	-- ** Bus names
	, BusName
	, busName
	, busName_
	, busNameText
	) where

import qualified Control.Exception
import           Data.Bits ((.|.))
import qualified Data.Set
import           Data.Word (Word32)

import           DBus.Address
import           DBus.Client hiding (call)
import           DBus.Connection.Error
import qualified DBus.MatchRule
import           DBus.Message hiding (errorName)
import           DBus.Types
import           DBus.Util (maybeIndex)

|DBus.Client.Simple|
:

:f DBus/Introspection.hs
{-# LANGUAGE OverloadedStrings #-}
|copyright|
module DBus.Introspection
	( Object (..)
	, Interface (..)
	, Method (..)
	, Signal (..)
	, Parameter (..)
	, Property (..)
	, PropertyAccess (..)
	, toXML
	, fromXML
	) where
import           Control.Monad ((>=>))
import           Control.Monad.ST (runST)
import           Data.Maybe (fromMaybe, listToMaybe)
import qualified Data.STRef as ST
import qualified Data.Text
import           Data.Text (Text)
import qualified Data.Text.Lazy
import qualified Data.XML.Types as X
import qualified Text.XML.LibXML.SAX as SAX

import qualified DBus.Types as T

|DBus.Introspection|
:

:f DBus/MatchRule.hs
{-# LANGUAGE OverloadedStrings #-}
|copyright|
module DBus.MatchRule (
	  MatchRule (..)
	, MessageType (..)
	, ParameterValue (..)
	, formatRule
	, addMatch
	, matchAll
	, matches
	) where
import           Data.Maybe (fromMaybe, mapMaybe)
import qualified Data.Set as Set
import qualified Data.Text as T
import           Data.Text (Text)
import           Data.Word (Word8)

import qualified DBus.Constants as C
import qualified DBus.Message as M
import qualified DBus.Types as T
import           DBus.Util (maybeIndex)

|DBus.MatchRule|
:
