:# Copyright (C) 2009-2011 John Millikin <jmillikin@gmail.com>
:# 
:# This program is free software: you can redistribute it and/or modify
:# it under the terms of the GNU General Public License as published by
:# the Free Software Foundation, either version 3 of the License, or
:# any later version.
:# 
:# This program is distributed in the hope that it will be useful,
:# but WITHOUT ANY WARRANTY; without even the implied warranty of
:# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
:# GNU General Public License for more details.
:# 
:# You should have received a copy of the GNU General Public License
:# along with this program.  If not, see <http://www.gnu.org/licenses/>.

\section{Wire format}

\subsection{Endianness}

:d DBus.Wire
data Endianness = LittleEndian | BigEndian
	deriving (Show, Eq)

encodeEndianness :: Endianness -> Word8
encodeEndianness LittleEndian = 108
encodeEndianness BigEndian    = 66

decodeEndianness :: Word8 -> Maybe Endianness
decodeEndianness 108 = Just LittleEndian
decodeEndianness 66  = Just BigEndian
decodeEndianness _   = Nothing
:

\subsection{Alignment}

Every built-in type has an associated alignment. If a value of the given
type is marshaled, it must have {\sc nul} bytes inserted until it starts
on a byte index divisible by its alignment.

:d DBus.Wire
alignment :: T.Type -> Word8
|alignments|

padding :: Word64 -> Word8 -> Word64
padding current count = required where
	count' = fromIntegral count
	missing = mod current count'
	required = if missing > 0
		then count' - missing
		else 0
:

\subsection{Marshaling}

Marshaling is implemented using an error transformer over an internal
state. The {\tt Builder} type is used for efficient construction of lazy
byte strings, but it doesn't provide any way to retrieve the length of its
internal buffer, so the byte count is tracked separately.

:d DBus.Wire
data MarshalState = MarshalState {-# UNPACK #-} !Data.Binary.Builder.Builder {-# UNPACK #-} !Word64

data MarshalR a = MarshalRL MarshalError | MarshalRR a {-# UNPACK #-} !MarshalState

type Marshal = MarshalM ()
newtype MarshalM a = MarshalM { unMarshalM :: Endianness -> MarshalState -> MarshalR a }

instance Monad MarshalM where
	{-# INLINE return #-}
	return a = MarshalM $ \_ s -> MarshalRR a s
	
	{-# INLINE (>>=) #-}
	m >>= k = MarshalM $ \e s -> case unMarshalM m e s of
		MarshalRL err -> MarshalRL err
		MarshalRR a s' -> unMarshalM (k a) e s'
	
	{-# INLINE (>>) #-}
	m >> k = MarshalM $ \e s -> case unMarshalM m e s of
		MarshalRL err -> MarshalRL err
		MarshalRR _ s' -> unMarshalM k e s'

throwMarshalError :: MarshalError -> MarshalM a
throwMarshalError err = MarshalM $ \_ _ -> MarshalRL err

{-# INLINE getMarshalState #-}
getMarshalState :: MarshalM MarshalState
getMarshalState = MarshalM $ \_ s -> MarshalRR s s

{-# INLINE putMarshalState #-}
putMarshalState :: MarshalState -> MarshalM ()
putMarshalState s = MarshalM $ \_ _ -> MarshalRR () s
:

Clients can perform marshaling via {\tt marshal} and {\tt runMarshal},
which will generate a {\tt ByteString} with the fully marshaled data.

:d DBus.Wire
runMarshal :: Marshal -> Endianness -> Either MarshalError Data.ByteString.Lazy.ByteString
runMarshal m e = case unMarshalM m e (MarshalState Data.Binary.Builder.empty 0) of
	MarshalRL err -> Left err
	MarshalRR _ (MarshalState builder _) -> Right $ Data.Binary.Builder.toLazyByteString builder
:

:d DBus.Wire
marshal :: T.Value -> Marshal
marshal v = case v of
	|marshalers|
:

TODO: describe these functions

:d DBus.Wire
appendS :: Data.ByteString.ByteString -> Marshal
appendS bytes = MarshalM $ \_ (MarshalState builder count) -> let
	builder' = Data.Binary.Builder.append builder $ Data.Binary.Builder.fromByteString bytes
	count' = count + fromIntegral (Data.ByteString.length bytes)
	in MarshalRR () (MarshalState builder' count')
:

:d DBus.Wire
appendL :: Data.ByteString.Lazy.ByteString -> Marshal
appendL bytes = MarshalM $ \_ (MarshalState builder count) -> let
	builder' = Data.Binary.Builder.append builder $ Data.Binary.Builder.fromLazyByteString bytes
	count' = count + fromIntegral (Data.ByteString.Lazy.length bytes)
	in MarshalRR () (MarshalState builder' count')
:

:d DBus.Wire
pad :: Word8 -> Marshal
pad count = MarshalM $ \e s@(MarshalState _ existing) -> let
	padding' = fromIntegral $ padding existing count
	bytes = Data.ByteString.replicate padding' 0
	in unMarshalM (appendS bytes) e s
:

Most numeric values already have marshalers implemented in the
{\tt Data.Binary.Builder} module; this function lets them be re-used easily.

:d DBus.Wire
marshalBuilder :: Word8 -> (a -> Data.Binary.Builder.Builder) -> (a -> Data.Binary.Builder.Builder) -> a -> Marshal
marshalBuilder size be le x = do
	pad size
	MarshalM $ \e (MarshalState builder count) -> let
		builder' = Data.Binary.Builder.append builder $ case e of
			BigEndian -> be x
			LittleEndian -> le x
		size' = fromIntegral size
		in MarshalRR () (MarshalState builder' (count + size'))
:

\subsubsection*{Errors}

Marshaling can fail for four reasons:

\begin{itemize}
\item The message exceeds the maximum message size of $2^{27}$ bytes.
\item An array in the message exceeds the maximum array size of $2^{26}$ bytes.
\item The body's signature is not valid (for example, more than 255 fields).
\item A variant's signature is not valid -- same causes as an invalid body
      signature.
\item Some text is invalid -- for example, it contains {\sc nul}
      ({\tt '\textbackslash{}0'}) or invalid Unicode.
\end{itemize}

:d DBus.Wire
data MarshalError
	= MessageTooLong Word64
	| ArrayTooLong Word64
	| InvalidBodySignature Text
	| InvalidVariantSignature Text
	| InvalidText Text
	deriving (Eq)

instance Show MarshalError where
	show (MessageTooLong x) = concat
		["Message too long (", show x, " bytes)."]
	show (ArrayTooLong x) = concat
		["Array too long (", show x, " bytes)."]
	show (InvalidBodySignature x) = concat
		["Invalid body signature: ", show x]
	show (InvalidVariantSignature x) = concat
		["Invalid variant signature: ", show x]
	show (InvalidText x) = concat
		["Text cannot be marshaled: ", show x]
:

\subsection{Unmarshaling}

Unmarshaling also uses an error transformer and internal state.

A specialised, state-like monad is used for performance reasons. This is
equivalent to {\tt State.StateT UnmarshalState (E.ErrorM UnmarshalError)}.

:d DBus.Wire
data UnmarshalState = UnmarshalState Data.ByteString.Lazy.ByteString {-# UNPACK #-} !Word64

data UnmarshalR a = UnmarshalRL UnmarshalError | UnmarshalRR a {-# UNPACK #-} !UnmarshalState

newtype Unmarshal a = Unmarshal { unUnmarshal :: Endianness -> UnmarshalState -> UnmarshalR a }

instance Monad Unmarshal where
	{-# INLINE return #-}
	return a = Unmarshal $ \_ s -> UnmarshalRR a s
	
	{-# INLINE (>>=) #-}
	m >>= k = Unmarshal $ \e s -> case unUnmarshal m e s of
		UnmarshalRL err -> UnmarshalRL err
		UnmarshalRR a s' -> unUnmarshal (k a) e s'
	
	{-# INLINE (>>) #-}
	m >> k = Unmarshal $ \e s -> case unUnmarshal m e s of
		UnmarshalRL err -> UnmarshalRL err
		UnmarshalRR _ s' -> unUnmarshal k e s'

throwUnmarshalError :: UnmarshalError -> Unmarshal a
throwUnmarshalError err = Unmarshal $ \_ _ -> UnmarshalRL err

{-# INLINE getUnmarshalState #-}
getUnmarshalState :: Unmarshal UnmarshalState
getUnmarshalState = Unmarshal $ \_ s -> UnmarshalRR s s

{-# INLINE putUnmarshalState #-}
putUnmarshalState :: UnmarshalState -> Unmarshal ()
putUnmarshalState s = Unmarshal $ \_ _ -> UnmarshalRR () s
:

:d DBus.Wire
runUnmarshal :: Unmarshal a -> Endianness -> Data.ByteString.Lazy.ByteString -> Either UnmarshalError a
runUnmarshal m e bytes = case unUnmarshal m e (UnmarshalState bytes 0) of
	UnmarshalRL err -> Left err
	UnmarshalRR a _ -> Right a
:

:d DBus.Wire
unmarshal :: T.Signature -> Unmarshal [T.Value]
unmarshal = mapM unmarshalType . T.signatureTypes

unmarshalType :: T.Type -> Unmarshal T.Value
|unmarshalers|
:

TODO: describe these functions

:d DBus.Wire
{-# INLINE consume #-}
consume :: Word64 -> Unmarshal Data.ByteString.Lazy.ByteString
consume count = Unmarshal $ \_ (UnmarshalState bytes offset) -> let
	count' = fromIntegral count
	(x, bytes') = Data.ByteString.Lazy.splitAt count' bytes
	in if Data.ByteString.Lazy.length x == count'
		then UnmarshalRR x (UnmarshalState bytes' (offset + count))
		else UnmarshalRL $ UnexpectedEOF offset
:

:d DBus.Wire
skipPadding :: Word8 -> Unmarshal ()
skipPadding count = do
	(UnmarshalState _ offset) <- getUnmarshalState
	bytes <- consume $ padding offset count
	unless (Data.ByteString.Lazy.all (== 0) bytes) $
		throwUnmarshalError $ InvalidPadding offset
:

:d DBus.Wire
skipTerminator :: Unmarshal ()
skipTerminator = do
	(UnmarshalState _ offset) <- getUnmarshalState
	bytes <- consume 1
	unless (Data.ByteString.Lazy.all (== 0) bytes) $
		throwUnmarshalError $ MissingTerminator offset
:

:d DBus.Wire
fromMaybeU :: Show a => Text -> (a -> Maybe b) -> a -> Unmarshal b
fromMaybeU = fromMaybeU2 show

fromMaybeU2 :: (a -> String) -> Text -> (a -> Maybe b) -> a -> Unmarshal b
fromMaybeU2 show' label f x = case f x of
	Just x' -> return x'
	Nothing -> throwUnmarshalError . Invalid label . Data.Text.pack . show' $ x

fromMaybeU' :: (Show a, T.IsValue b) => Text -> (a -> Maybe b) -> a
           -> Unmarshal T.Value
fromMaybeU' label f x = do
	x' <- fromMaybeU label f x
	return $ T.toValue x'
:

:d DBus.Wire
unmarshalGet :: Word8 -> Data.Binary.Get.Get a -> Data.Binary.Get.Get a -> Unmarshal a
unmarshalGet count be le = do
	skipPadding count
	bs <- consume . fromIntegral $ count
	
	Unmarshal $ \e s -> let
		get = case e of
			BigEndian -> be
			LittleEndian -> le
		in UnmarshalRR (Data.Binary.Get.runGet get bs) s

unmarshalGet' :: T.IsValue a => Word8 -> Data.Binary.Get.Get a -> Data.Binary.Get.Get a
              -> Unmarshal T.Value
unmarshalGet' count be le = T.toValue `liftM` unmarshalGet count be le
:

:d DBus.Wire
untilM :: Monad m => m Bool -> m a -> m [a]
untilM test comp = do
	done <- test
	if done
		then return []
		else do
			x <- comp
			xs <- untilM test comp
			return $ x:xs
:

\subsubsection*{Errors}

Unmarshaling can fail for four reasons:

\begin{itemize}
\item The message's declared protocol version is unsupported.
\item Unexpected {\sc eof}, when there are less bytes remaining than are
      required.
\item An invalid byte sequence for a given value type.
\item Missing required header fields for the declared message type.
\item Non-zero bytes were found where padding was expected.
\item A string, signature, or object path was not {\sc null}-terminated.
\item An array's size didn't match the number of elements
\end{itemize}

:d DBus.Wire
data UnmarshalError
	= UnsupportedProtocolVersion Word8
	| UnexpectedEOF Word64
	| Invalid Text Text
	| MissingHeaderField Text
	| InvalidHeaderField Text T.Variant
	| InvalidPadding Word64
	| MissingTerminator Word64
	| ArraySizeMismatch
	deriving (Eq)

instance Show UnmarshalError where
	show (UnsupportedProtocolVersion x) = concat
		["Unsupported protocol version: ", show x]
	show (UnexpectedEOF pos) = concat
		["Unexpected EOF at position ", show pos]
	show (Invalid label x) = Data.Text.unpack $ Data.Text.concat
		["Invalid ", label, ": ", x]
	show (MissingHeaderField x) = concat
		["Required field " , show x , " is missing."]
	show (InvalidHeaderField x got) = concat
		[ "Invalid header field ", show x, ": ", show got]
	show (InvalidPadding pos) = concat
		["Invalid padding at position ", show pos]
	show (MissingTerminator pos) = concat
		["Missing NUL terminator at position ", show pos]
	show ArraySizeMismatch = "Array size mismatch"
:

\subsection{Numerics}

Numeric values are fixed-length, and aligned ``naturally'' -- ie, a 4-byte
integer will have a 4-byte alignment.

:d alignments
alignment T.TypeWord8   = 1
alignment T.TypeWord16  = 2
alignment T.TypeWord32  = 4
alignment T.TypeWord64  = 8
alignment T.TypeInt16   = 2
alignment T.TypeInt32   = 4
alignment T.TypeInt64   = 8
alignment T.TypeDouble  = 8
:

Because some integral types are often used as components of other values,
there's separate functions for handling them.

:d DBus.Wire
marshalWord32 :: Word32 -> Marshal
marshalWord32 = marshalBuilder 4 Data.Binary.Builder.putWord32be Data.Binary.Builder.putWord32le
:

:d DBus.Wire
{-# INLINE marshalWord8 #-}
marshalWord8 :: Word8 -> Marshal
marshalWord8 x = MarshalM $ \_ (MarshalState builder count) -> let
	builder' = Data.Binary.Builder.append builder $ Data.Binary.Builder.singleton x
	in MarshalRR () (MarshalState builder' (count + 1))
:

:d DBus.Wire
unmarshalWord32 :: Unmarshal Word32
unmarshalWord32 = unmarshalGet 4 Data.Binary.Get.getWord32be Data.Binary.Get.getWord32le
:

:d marshalers
T.ValueAtom (T.AtomWord8  x) -> marshalWord8 x
T.ValueAtom (T.AtomWord16 x) -> marshalBuilder 2 Data.Binary.Builder.putWord16be Data.Binary.Builder.putWord16le x
T.ValueAtom (T.AtomWord32 x) -> marshalWord32 x
T.ValueAtom (T.AtomWord64 x) -> marshalBuilder 8 Data.Binary.Builder.putWord64be Data.Binary.Builder.putWord64le x
T.ValueAtom (T.AtomInt16  x) -> marshalBuilder 2 Data.Binary.Builder.putWord16be Data.Binary.Builder.putWord16le $ fromIntegral x
T.ValueAtom (T.AtomInt32  x) -> marshalBuilder 4 Data.Binary.Builder.putWord32be Data.Binary.Builder.putWord32le $ fromIntegral x
T.ValueAtom (T.AtomInt64  x) -> marshalBuilder 8 Data.Binary.Builder.putWord64be Data.Binary.Builder.putWord64le $ fromIntegral x
:

:d unmarshalers
unmarshalType T.TypeWord8 = liftM (T.toValue . Data.ByteString.Lazy.head) $ consume 1
unmarshalType T.TypeWord16 = unmarshalGet' 2 Data.Binary.Get.getWord16be Data.Binary.Get.getWord16le
unmarshalType T.TypeWord32 = unmarshalGet' 4 Data.Binary.Get.getWord32be Data.Binary.Get.getWord32le
unmarshalType T.TypeWord64 = unmarshalGet' 8 Data.Binary.Get.getWord64be Data.Binary.Get.getWord64le

unmarshalType T.TypeInt16  = do
	x <- unmarshalGet 2 Data.Binary.Get.getWord16be Data.Binary.Get.getWord16le
	return . T.toValue $ (fromIntegral x :: Int16)

unmarshalType T.TypeInt32  = do
	x <- unmarshalGet 4 Data.Binary.Get.getWord32be Data.Binary.Get.getWord32le
	return . T.toValue $ (fromIntegral x :: Int32)

unmarshalType T.TypeInt64  = do
	x <- unmarshalGet 8 Data.Binary.Get.getWord64be Data.Binary.Get.getWord64le
	return . T.toValue $ (fromIntegral x :: Int64)
:

{\tt Double}s are marshaled as in-bit IEEE-754 floating-point format.

:d marshalers
T.ValueAtom (T.AtomDouble x) -> marshalDouble x
:

:d DBus.Wire
marshalDouble :: Double -> Marshal
marshalDouble x = do
	pad 8
	MarshalM $ \e s -> let
		put = case e of
			BigEndian -> Data.Binary.IEEE754.putFloat64be
			LittleEndian -> Data.Binary.IEEE754.putFloat64le
		bytes = runPut $ put x
		in unMarshalM (appendL bytes) e s
:

:d unmarshalers
unmarshalType T.TypeDouble = unmarshalGet' 8 Data.Binary.IEEE754.getFloat64be Data.Binary.IEEE754.getFloat64le
:

\subsection{Booleans}

Booleans are marshaled as 4-byte unsigned integers containing either of
the values 0 or 1. Yes, really.

:d alignments
alignment T.TypeBoolean = 4
:

:d marshalers
T.ValueAtom (T.AtomBool x) -> marshalWord32 $ if x then 1 else 0
:

:d unmarshalers
unmarshalType T.TypeBoolean = unmarshalWord32 >>=
	fromMaybeU' "boolean" (\x -> case x of
		0 -> Just False
		1 -> Just True
		_ -> Nothing)
:

\subsection{Strings and object paths}

Strings are encoded in {\sc utf-8}, terminated with {\tt NUL}, and prefixed
with their length as an unsigned 32-bit integer. Their alignment is that of
their length. Object paths are marshaled just like strings, though additional
checks are required when unmarshaling.

Because the encoding functions from {\tt Data.Text} raise exceptions on
error, checking their return value requires some ugly workarounds.

:d DBus.Wire.Unicode
excToMaybe :: a -> Maybe a
excToMaybe x = unsafePerformIO $ fmap Just (Exc.evaluate x) `Exc.catch` unicodeError

unicodeError :: UnicodeException -> IO (Maybe a)
unicodeError = const $ return Nothing

maybeEncodeUtf8 :: Text -> Maybe ByteString
maybeEncodeUtf8 = excToMaybe . encodeUtf8

maybeDecodeUtf8 :: ByteString -> Maybe Text
maybeDecodeUtf8 = excToMaybe . decodeUtf8
:

:d DBus.Wire
marshalText :: Text -> Marshal
marshalText x = do
	bytes <- case maybeEncodeUtf8 x of
		Just x' -> return x'
		Nothing -> throwMarshalError $ InvalidText x
	when (Data.ByteString.any (== 0) bytes) $
		throwMarshalError $ InvalidText x
	marshalWord32 . fromIntegral . Data.ByteString.length $ bytes
	appendS bytes
	marshalWord8 0
:

:d DBus.Wire
unmarshalText :: Unmarshal Text
unmarshalText = do
	byteCount <- unmarshalWord32
	bytes <- consume . fromIntegral $ byteCount
	skipTerminator
	fromMaybeU "text" maybeDecodeUtf8 (Data.ByteString.concat (Data.ByteString.Lazy.toChunks bytes))
:

:d alignments
alignment T.TypeString     = 4
alignment T.TypeObjectPath = 4
:

:d marshalers
T.ValueAtom (T.AtomText x) -> marshalText x
T.ValueAtom (T.AtomObjectPath x) -> marshalText . T.objectPathText $ x
:

:d unmarshalers
unmarshalType T.TypeString = liftM T.toValue unmarshalText

unmarshalType T.TypeObjectPath = unmarshalText >>=
	fromMaybeU' "object path" T.objectPath
:

\subsection{Signatures}

Signatures are similar to strings, except their length is limited to 255
characters and is therefore stored as a single byte.

:d DBus.Wire
signatureBytes :: T.Signature -> Data.ByteString.ByteString
signatureBytes (T.Signature ts) = Data.ByteString.Char8.pack (concatMap T.typeCode ts)

marshalSignature :: T.Signature -> Marshal
marshalSignature x = do
	let bytes = signatureBytes x
	let size = fromIntegral . Data.ByteString.length $ bytes
	marshalWord8 size
	appendS bytes
	marshalWord8 0
:

:d DBus.Wire
unmarshalSignature :: Unmarshal T.Signature
unmarshalSignature = do
	byteCount <- Data.ByteString.Lazy.head `liftM` consume 1
	lazy <- consume $ fromIntegral byteCount
	skipTerminator
	let bytes = Data.ByteString.concat $ Data.ByteString.Lazy.toChunks lazy
	fromMaybeU "signature" T.parseSignature bytes
:

:d alignments
alignment T.TypeSignature  = 1
:

:d marshalers
T.ValueAtom (T.AtomSignature x) -> marshalSignature x
:

:d unmarshalers
unmarshalType T.TypeSignature = liftM T.toValue unmarshalSignature
:

\subsection{Containers}

\subsubsection*{Arrays}

:d alignments
alignment (T.TypeArray _) = 4
:

:d marshalers
T.ValueVector t x -> marshalArray t x
:

:d unmarshalers
unmarshalType t@(T.TypeArray t') = T.ValueVector t `liftM` unmarshalArray t'
:

Marshaling arrays is complicated, because the array body must be marshaled
\emph{first} to calculate the array length. This requires building a
temporary marshaler, to get the padding right.

:d DBus.Wire
marshalArray :: T.Type -> Vector T.Value -> Marshal
marshalArray t x = do
	(arrayPadding, arrayBytes) <- getArrayBytes t x
	let arrayLen = Data.ByteString.Lazy.length arrayBytes
	when (arrayLen > fromIntegral C.arrayMaximumLength)
		(throwMarshalError $ ArrayTooLong $ fromIntegral arrayLen)
	marshalWord32 $ fromIntegral arrayLen
	appendL $ Data.ByteString.Lazy.replicate arrayPadding 0
	appendL arrayBytes
:

:d DBus.Wire
getArrayBytes :: T.Type -> Vector T.Value -> MarshalM (Int64, Data.ByteString.Lazy.ByteString)
getArrayBytes itemType vs = do
	s <- getMarshalState
	(MarshalState _ afterLength) <- marshalWord32 0 >> getMarshalState
	(MarshalState _ afterPadding) <- pad (alignment itemType) >> getMarshalState
	
	putMarshalState $ MarshalState Data.Binary.Builder.empty afterPadding
	(MarshalState itemBuilder _) <- Data.Vector.mapM_ marshal vs >> getMarshalState
	
	let itemBytes = Data.Binary.Builder.toLazyByteString itemBuilder
	    paddingSize = fromIntegral $ afterPadding - afterLength
	
	putMarshalState s
	return (paddingSize, itemBytes)
:

Unmarshaling is much easier, especially if it's a byte array.

:d DBus.Wire
unmarshalArray :: T.Type -> Unmarshal (Vector T.Value)
unmarshalArray itemType = do
	let getOffset = do
		(UnmarshalState _ o) <- getUnmarshalState
		return o
	byteCount <- unmarshalWord32
	skipPadding (alignment itemType)
	start <- getOffset
	let end = start + fromIntegral byteCount
	vs <- untilM (liftM (>= end) getOffset) (unmarshalType itemType)
	end' <- getOffset
	when (end' > end) $
		throwUnmarshalError ArraySizeMismatch
	return (Data.Vector.fromList vs)
:

\subsubsection*{Dictionaries}

:d DBus.Wire
dictionaryToArray :: Map T.Atom T.Value -> Vector T.Value
dictionaryToArray = Data.Vector.fromList . map step . Data.Map.toList where
	step (k, v) = T.ValueStructure [T.ValueAtom k, v]
:

:d DBus.Wire
arrayToDictionary :: Vector T.Value -> Map T.Atom T.Value
arrayToDictionary = Data.Map.fromList . map step . Data.Vector.toList where
	step (T.ValueStructure [T.ValueAtom k, v]) = (k, v)
	step _ = error "arrayToDictionary: internal error"
:

:d alignments
alignment (T.TypeDictionary _ _) = 4
:

:d marshalers
T.ValueMap t x -> let
	T.TypeDictionary kt vt = t
	structType = T.TypeStructure [kt, vt]
	array = dictionaryToArray x
	in marshalArray structType array
:

:d unmarshalers
unmarshalType t@(T.TypeDictionary kt vt) = do
	let pairType = T.TypeStructure [kt, vt]
	array <- unmarshalArray pairType
	return (T.ValueMap t (arrayToDictionary array))
:

\subsubsection*{Structures}

:d alignments
alignment (T.TypeStructure _) = 8
:

:d marshalers
T.ValueStructure vs -> do
	pad 8
	mapM_ marshal vs
:

:d unmarshalers
unmarshalType (T.TypeStructure ts) = do
	skipPadding 8
	liftM T.ValueStructure $ mapM unmarshalType ts
:

\subsubsection*{Variants}

:d alignments
alignment T.TypeVariant = 1
:

:d marshalers
T.ValueVariant (T.Variant val) -> do
	let textSig = Data.Text.pack (T.typeCode (T.valueType val))
	sig <- case T.signature textSig of
		Just x' -> return x'
		Nothing -> throwMarshalError $ InvalidVariantSignature textSig
	marshalSignature sig
	marshal val
:

:d unmarshalers
unmarshalType T.TypeVariant = do
	let getType sig = case T.signatureTypes sig of
		[t] -> Just t
		_   -> Nothing
	
	t <- fromMaybeU "variant signature" getType =<< unmarshalSignature
	(T.toValue . T.Variant) `liftM` unmarshalType t
:

\subsection{Messages}

\subsubsection*{Flags}

:d DBus.Wire
encodeFlags :: Data.Set.Set M.Flag -> Word8
encodeFlags flags = foldr (.|.) 0 $ map flagValue $ Data.Set.toList flags where
	flagValue M.NoReplyExpected = 0x1
	flagValue M.NoAutoStart     = 0x2
:

:d DBus.Wire
decodeFlags :: Word8 -> Data.Set.Set M.Flag
decodeFlags word = Data.Set.fromList flags where
	flagSet = [ (0x1, M.NoReplyExpected)
	          , (0x2, M.NoAutoStart)
	          ]
	flags = flagSet >>= \(x, y) -> [y | word .&. x > 0]
:

\subsubsection*{Header fields}

:d DBus.Wire
encodeField :: M.HeaderField -> T.Value
encodeField (M.Path x)        = encodeField' 1 x
encodeField (M.Interface x)   = encodeField' 2 x
encodeField (M.Member x)      = encodeField' 3 x
encodeField (M.ErrorName x)   = encodeField' 4 x
encodeField (M.ReplySerial x) = encodeField' 5 x
encodeField (M.Destination x) = encodeField' 6 x
encodeField (M.Sender x)      = encodeField' 7 x
encodeField (M.Signature x)   = encodeField' 8 x

encodeField' :: T.IsVariant a => Word8 -> a -> T.Value
encodeField' code x = T.toValue (code, T.toVariant x)
:

:d DBus.Wire
decodeField :: (Word8, T.Variant)
            -> E.ErrorM UnmarshalError [M.HeaderField]
decodeField struct = case struct of
	(1, x) -> decodeField' x M.Path "path"
	(2, x) -> decodeField' x M.Interface "interface"
	(3, x) -> decodeField' x M.Member "member"
	(4, x) -> decodeField' x M.ErrorName "error name"
	(5, x) -> decodeField' x M.ReplySerial "reply serial"
	(6, x) -> decodeField' x M.Destination "destination"
	(7, x) -> decodeField' x M.Sender "sender"
	(8, x) -> decodeField' x M.Signature "signature"
	_      -> return []

decodeField' :: T.IsVariant a => T.Variant -> (a -> b) -> Text
             -> E.ErrorM UnmarshalError [b]
decodeField' x f label = case T.fromVariant x of
	Just x' -> return [f x']
	Nothing -> E.throwErrorM $ InvalidHeaderField label x
:

\subsubsection*{Header layout}

TODO: describe header layout here

\subsubsection*{Marshaling}

:d DBus.Wire
|apidoc marshalMessage|
marshalMessage :: M.Message a => Endianness -> M.Serial -> a
               -> Either MarshalError Data.ByteString.Lazy.ByteString
marshalMessage e serial msg = runMarshal marshaler e where
	body = M.messageBody msg
	marshaler = do
		sig <- checkBodySig body
		empty <- getMarshalState
		mapM_ (marshal . (\(T.Variant x) -> x)) body
		(MarshalState bodyBytesB _) <- getMarshalState
		putMarshalState empty
		marshalEndianness e
		let bodyBytes = Data.Binary.Builder.toLazyByteString bodyBytesB
		marshalHeader msg serial sig
			$ fromIntegral . Data.ByteString.Lazy.length $ bodyBytes
		pad 8
		appendL bodyBytes
		checkMaximumSize
:

:d DBus.Wire
checkBodySig :: [T.Variant] -> MarshalM T.Signature
checkBodySig vs = let
	strSig = concatMap (T.typeCode . T.variantType) vs
	textSig = Data.Text.pack strSig
	bytesSig = Data.ByteString.Char8.pack strSig
	invalid = throwMarshalError $ InvalidBodySignature textSig
	in case T.parseSignature bytesSig of
		Just x -> return x
		Nothing -> invalid
:

:d DBus.Wire
marshalHeader :: M.Message a => a -> M.Serial -> T.Signature -> Word32
              -> Marshal
marshalHeader msg serial bodySig bodyLength = do
	let fields = M.Signature bodySig : M.messageHeaderFields msg
	marshalWord8 . M.messageTypeCode $ msg
	marshalWord8 . encodeFlags . M.messageFlags $ msg
	marshalWord8 C.protocolVersion
	marshalWord32 bodyLength
	marshalWord32 . M.serialValue $ serial
	let fieldType = T.TypeStructure [T.TypeWord8, T.TypeVariant]
	marshalArray fieldType (Data.Vector.fromList (map encodeField fields))
:

:d DBus.Wire
marshalEndianness :: Endianness -> Marshal
marshalEndianness = marshal . T.toValue . encodeEndianness
:

:d DBus.Wire
checkMaximumSize :: Marshal
checkMaximumSize = do
	(MarshalState _ messageLength) <- getMarshalState
	when (messageLength > fromIntegral C.messageMaximumLength)
		(throwMarshalError $ MessageTooLong $ fromIntegral messageLength)
:

\subsubsection*{Unmarshaling}

:d DBus.Wire
|apidoc unmarshalMessage|
unmarshalMessage :: Monad m => (Word32 -> m Data.ByteString.Lazy.ByteString)
                 -> m (Either UnmarshalError M.ReceivedMessage)
unmarshalMessage getBytes' = E.runErrorT $ do
	let getBytes = E.ErrorT . liftM Right . getBytes'
	
	|read fixed-length header|
	|read full header|
	|read body|
	|build message|
:

The first part of the header has a fixed size of 16 bytes, so it can be
retrieved without any size calculations.

:d read fixed-length header
let fixedSig = "yyyyuuu"
fixedBytes <- getBytes 16
:

The first field of interest is the protocol version; if the incoming
message's version is different from this library, the message cannot be
parsed.

:d read fixed-length header
let messageVersion = Data.ByteString.Lazy.index fixedBytes 3
when (messageVersion /= C.protocolVersion) $
	E.throwErrorT $ UnsupportedProtocolVersion messageVersion
:

Next is the endianness, used for parsing pretty much every other field.

:d read fixed-length header
let eByte = Data.ByteString.Lazy.index fixedBytes 0
endianness <- case decodeEndianness eByte of
	Just x' -> return x'
	Nothing -> E.throwErrorT . Invalid "endianness" . Data.Text.pack . show $ eByte
:

With the endianness out of the way, the rest of the fixed header
can be decoded

:d read fixed-length header
let unmarshal' x bytes = case runUnmarshal (unmarshal x) endianness bytes of
	Right x' -> return x'
	Left  e  -> E.throwErrorT e
fixed <- unmarshal' fixedSig fixedBytes
let typeCode = fromJust . T.fromValue $ fixed !! 1
let flags = decodeFlags . fromJust . T.fromValue $ fixed !! 2
let bodyLength = fromJust . T.fromValue $ fixed !! 4
let serial = fromJust . T.fromVariant $ T.Variant (fixed !! 5)
:

The last field of the fixed header is actually part of the field array,
but is treated as a single {\tt Word32} so it'll be known how many bytes
to retrieve.

:d read fixed-length header
let fieldByteCount = fromJust . T.fromValue $ fixed !! 6
:

With the field byte count, the remainder of the header bytes can be
pulled out of the monad.

:d read full header
let headerSig  = "yyyyuua(yv)"
fieldBytes <- getBytes fieldByteCount
let headerBytes = Data.ByteString.Lazy.append fixedBytes fieldBytes
header <- unmarshal' headerSig headerBytes
:

And the header fields can be parsed.

:d read full header
let fieldArray = Data.Vector.toList (fromJust . T.fromValue $ header !! 6)
fields <- case E.runErrorM $ concat `liftM` mapM decodeField fieldArray of
	Left err -> E.throwErrorT err
	Right x -> return x
:

The body is always aligned to 8 bytes, so pull out the padding before
unmarshaling it.

:d read body
let bodyPadding = padding (fromIntegral fieldByteCount + 16) 8
void (getBytes (fromIntegral bodyPadding))
:

:d DBus.Wire
findBodySignature :: [M.HeaderField] -> T.Signature
findBodySignature fields = fromMaybe "" signature where
	signature = listToMaybe [x | M.Signature x <- fields]
:

:d read body
let bodySig = findBodySignature fields
:

Then pull the body bytes, and unmarshal it.

:d read body
bodyBytes <- getBytes bodyLength
body <- unmarshal' bodySig bodyBytes
:

Even if the received message was structurally valid, building the
{\tt ReceivedMessage} can still fail due to missing header fields.

:d build message
y <- case E.runErrorM $ buildReceivedMessage typeCode fields of
	Right x -> return x
	Left err -> E.throwErrorT $ MissingHeaderField err
return $ y serial flags (map T.Variant body)
:

This really belongs in the Message section...

:d DBus.Wire
buildReceivedMessage :: Word8 -> [M.HeaderField] -> E.ErrorM Text
                        (M.Serial -> (Data.Set.Set M.Flag) -> [T.Variant]
                         -> M.ReceivedMessage)
:

Method calls

:d DBus.Wire
buildReceivedMessage 1 fields = do
	path <- require "path" [x | M.Path x <- fields]
	member <- require "member name" [x | M.Member x <- fields]
	return $ \serial flags body -> let
		iface = listToMaybe [x | M.Interface x <- fields]
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.MethodCall path member iface dest flags body
		in M.ReceivedMethodCall serial sender msg
:

Method returns

:d DBus.Wire
buildReceivedMessage 2 fields = do
	replySerial <- require "reply serial" [x | M.ReplySerial x <- fields]
	return $ \serial _ body -> let
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.MethodReturn replySerial dest body
		in M.ReceivedMethodReturn serial sender msg
:

Errors

:d DBus.Wire
buildReceivedMessage 3 fields = do
	name <- require "error name" [x | M.ErrorName x <- fields]
	replySerial <- require "reply serial" [x | M.ReplySerial x <- fields]
	return $ \serial _ body -> let
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.Error name replySerial dest body
		in M.ReceivedError serial sender msg
:

Signals

:d DBus.Wire
buildReceivedMessage 4 fields = do
	path <- require "path" [x | M.Path x <- fields]
	member <- require "member name" [x | M.Member x <- fields]
	iface <- require "interface" [x | M.Interface x <- fields]
	return $ \serial _ body -> let
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.Signal path member iface dest body
		in M.ReceivedSignal serial sender msg
:

Unknown

:d DBus.Wire
buildReceivedMessage typeCode fields = return $ \serial flags body -> let
	sender = listToMaybe [x | M.Sender x <- fields]
	msg = M.Unknown typeCode flags body
	in M.ReceivedUnknown serial sender msg
:

:d DBus.Wire
require :: Text -> [a] -> E.ErrorM Text a
require _     (x:_) = return x
require label _     = E.throwErrorM label
:
