:# Copyright (C) 2009-2011 John Millikin <jmillikin@gmail.com>
:# 
:# This program is free software: you can redistribute it and/or modify
:# it under the terms of the GNU General Public License as published by
:# the Free Software Foundation, either version 3 of the License, or
:# any later version.
:# 
:# This program is distributed in the hope that it will be useful,
:# but WITHOUT ANY WARRANTY; without even the implied warranty of
:# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
:# GNU General Public License for more details.
:# 
:# You should have received a copy of the GNU General Public License
:# along with this program.  If not, see <http://www.gnu.org/licenses/>.

\section{Wire format}

\dbus{} uses a simple binary format to serialize messages. Every message has
a \emph{header}, which describes the message itself, and a \emph{body}, which
contains application-specific values.

\clearpage
\subsection{Serialization monads}

Messages can be quite large, so it's important that both the serializer and
parser be efficient. The standard {\tt Get} and {\tt Put} monads are too slow,
so I define my own monads for building and parsing binary data. These are
equivalent to an {\tt ErrorT . StateT} stack, but inlined and strict.

:d DBus.Wire
data Endianness = LittleEndian | BigEndian
	deriving (Show, Eq)

encodeEndianness :: Endianness -> Word8
encodeEndianness LittleEndian = 108
encodeEndianness BigEndian    = 66

decodeEndianness :: Word8 -> Maybe Endianness
decodeEndianness 108 = Just LittleEndian
decodeEndianness 66  = Just BigEndian
decodeEndianness _   = Nothing
:

:d DBus.Wire
data WireR e s a
	= WireRL e
	| WireRR a {-# UNPACK #-} !s

newtype Wire e s a = Wire
	{ unWire :: Endianness -> s -> WireR e s a
	}

instance Monad (Wire e s) where
	{-# INLINE return #-}
	return a = Wire (\_ s -> WireRR a s)
	
	{-# INLINE (>>=) #-}
	m >>= k = Wire $ \e s -> case unWire m e s of
		WireRL err -> WireRL err
		WireRR a s' -> unWire (k a) e s'
	
	{-# INLINE (>>) #-}
	m >> k = Wire $ \e s -> case unWire m e s of
		WireRL err -> WireRL err
		WireRR _ s' -> unWire k e s'

throwError :: e -> Wire e s a
throwError err = Wire (\_ _ -> WireRL err)

{-# INLINE getState #-}
getState :: Wire e s s
getState = Wire (\_ s -> WireRR s s)

{-# INLINE putState #-}
putState :: s -> Wire e s ()
putState s = Wire (\_ _ -> WireRR () s)
:

\clearpage
\subsubsection{Marshaling}

Marshaling is the process of converting a sequence of values into a
{\tt ByteString}.

\begin{multicols}{2}

TODO

\vfill

\columnbreak

:d DBus.Wire
type Marshal = Wire MarshalError MarshalState

data MarshalState = MarshalState
	{-# UNPACK #-} !Data.Binary.Builder.Builder
	{-# UNPACK #-} !Word64
:

\end{multicols}

\begin{multicols}{2}

Marshaling may fail due to:

\begin{itemize}
\item The message exceeds the maximum message size of $2^{27}$ bytes.
\item An array in the message exceeds the maximum array size of $2^{26}$ bytes.
\item The body's signature is not valid (for example, more than 255 fields).
\item A variant's signature is not valid -- same causes as an invalid body
      signature.
\item Some text is invalid -- for example, it contains {\sc nul}
      ({\tt '\textbackslash{}0'}) or invalid Unicode.
\end{itemize}

\vfill

\columnbreak

:d DBus.Wire
data MarshalError
	= MessageTooLong Word64
	| ArrayTooLong Word64
	| InvalidBodySignature Text
	| InvalidVariantSignature Text
	| InvalidText Text
	deriving (Eq)

instance Show MarshalError where
	show (MessageTooLong x) = concat
		["Message too long (", show x, " bytes)."]
	show (ArrayTooLong x) = concat
		["Array too long (", show x, " bytes)."]
	show (InvalidBodySignature x) = concat
		["Invalid body signature: ", show x]
	show (InvalidVariantSignature x) = concat
		["Invalid variant signature: ", show x]
	show (InvalidText x) = concat
		["Text cannot be marshaled: ", show x]
:

\end{multicols}

\clearpage
\subsubsection{Unmarshaling}

\begin{multicols}{2}

TODO

\vfill

\columnbreak

:d DBus.Wire
type Unmarshal = Wire UnmarshalError UnmarshalState

data UnmarshalState = UnmarshalState
	Data.ByteString.Lazy.ByteString
	{-# UNPACK #-} !Word64
:

\end{multicols}

\begin{multicols}{2}

Unmarshaling may fail due to:

\begin{itemize}
\item The message's declared protocol version is unsupported.
\item Unexpected {\sc eof}, when there are less bytes remaining than are
      required.
\item An invalid byte sequence for a given value type.
\item Missing required header fields for the declared message type.
\item Non-zero bytes were found where padding was expected.
\item A string, signature, or object path was not {\sc null}-terminated.
\item An array's size didn't match the number of elements
\end{itemize}

\vfill

\columnbreak

:d DBus.Wire
data UnmarshalError
	= UnsupportedProtocolVersion Word8
	| UnexpectedEOF Word64
	| Invalid Text Text
	| MissingHeaderField Text
	| InvalidHeaderField Text T.Variant
	| InvalidPadding Word64
	| MissingTerminator Word64
	| ArraySizeMismatch
	deriving (Eq)

instance Show UnmarshalError where
	show (UnsupportedProtocolVersion x) = concat
		["Unsupported protocol version: ", show x]
	show (UnexpectedEOF pos) = concat
		["Unexpected EOF at position ", show pos]
	show (Invalid label x) = Data.Text.unpack $ Data.Text.concat
		["Invalid ", label, ": ", x]
	show (MissingHeaderField x) = concat
		["Required field " , show x , " is missing."]
	show (InvalidHeaderField x got) = concat
		[ "Invalid header field ", show x, ": ", show got]
	show (InvalidPadding pos) = concat
		["Invalid padding at position ", show pos]
	show (MissingTerminator pos) = concat
		["Missing NUL terminator at position ", show pos]
	show ArraySizeMismatch = "Array size mismatch"
:

\end{multicols}

\clearpage
\subsection{Marshaling values}

:d DBus.Wire
marshal :: T.Value -> Marshal ()
marshal (T.ValueAtom x) = marshalAtom x
marshal (T.ValueVector t xs) = marshalVector t xs
marshal (T.ValueMap t xs) = marshalMap t xs
marshal (T.ValueStructure xs) = marshalStructure xs
marshal (T.ValueVariant x) = marshalVariant x
:

:d DBus.Wire
marshalAtom :: T.Atom -> Marshal ()
marshalAtom (T.AtomWord8  x) = marshalWord8 x
marshalAtom (T.AtomWord16 x) = marshalWord16 x
marshalAtom (T.AtomWord32 x) = marshalWord32 x
marshalAtom (T.AtomWord64 x) = marshalWord64 x
marshalAtom (T.AtomInt16  x) = marshalInt16 x
marshalAtom (T.AtomInt32  x) = marshalInt32 x
marshalAtom (T.AtomInt64  x) = marshalInt64 x
marshalAtom (T.AtomDouble x) = marshalDouble x
marshalAtom (T.AtomBool x) = marshalBool x
marshalAtom (T.AtomText x) = marshalText x
marshalAtom (T.AtomObjectPath x) = marshalObjectPath x
marshalAtom (T.AtomSignature x) = marshalSignature x
:

\clearpage
\subsubsection{Alignment}

Every built-in type has an associated alignment. If a value of the given
type is marshaled, it must have {\sc nul} bytes inserted until it starts
on a byte index divisible by its alignment.

Numeric values are fixed-length, and aligned ``naturally'' -- ie, a 4-byte
integer will have a 4-byte alignment.

:d DBus.Wire
alignment :: T.Type -> Word8
alignment T.TypeBoolean = 4
alignment T.TypeWord8 = 1
alignment T.TypeWord16 = 2
alignment T.TypeWord32 = 4
alignment T.TypeWord64 = 8
alignment T.TypeInt16 = 2
alignment T.TypeInt32 = 4
alignment T.TypeInt64 = 8
alignment T.TypeDouble = 8
alignment T.TypeString = 4
alignment T.TypeObjectPath = 4
alignment T.TypeSignature = 1
alignment (T.TypeArray _) = 4
alignment (T.TypeDictionary _ _) = 4
alignment (T.TypeStructure _) = 8
alignment T.TypeVariant = 1
:

:d DBus.Wire
padding :: Word64 -> Word8 -> Word64
padding current count = required where
	count' = fromIntegral count
	missing = mod current count'
	required = if missing > 0
		then count' - missing
		else 0
:

\clearpage
\subsubsection{Integers}

:d DBus.Wire
marshalWord8 :: Word8 -> Marshal ()
marshalWord8 x = Wire $ \_ (MarshalState builder count) -> let
	builder' = Data.Binary.Builder.append builder $ Data.Binary.Builder.singleton x
	in WireRR () (MarshalState builder' (count + 1))

marshalWord16 :: Word16 -> Marshal ()
marshalWord16 = marshalBuilder 2
	Data.Binary.Builder.putWord16be
	Data.Binary.Builder.putWord16le

marshalWord32 :: Word32 -> Marshal ()
marshalWord32 = marshalBuilder 4
	Data.Binary.Builder.putWord32be
	Data.Binary.Builder.putWord32le

marshalWord64 :: Word64 -> Marshal ()
marshalWord64 = marshalBuilder 8
	Data.Binary.Builder.putWord64be
	Data.Binary.Builder.putWord64le

marshalInt16 :: Int16 -> Marshal ()
marshalInt16 = marshalWord16 . fromIntegral

marshalInt32 :: Int32 -> Marshal ()
marshalInt32 = marshalWord32 . fromIntegral

marshalInt64 :: Int64 -> Marshal ()
marshalInt64 = marshalWord64 . fromIntegral
:

:d DBus.Wire
unmarshalWord32 :: Unmarshal Word32
unmarshalWord32 = unmarshalGet 4 Data.Binary.Get.getWord32be Data.Binary.Get.getWord32le
:

:d unmarshalers
unmarshalType T.TypeWord8 = liftM (T.toValue . Data.ByteString.Lazy.head) $ consume 1
unmarshalType T.TypeWord16 = unmarshalGet' 2 Data.Binary.Get.getWord16be Data.Binary.Get.getWord16le
unmarshalType T.TypeWord32 = unmarshalGet' 4 Data.Binary.Get.getWord32be Data.Binary.Get.getWord32le
unmarshalType T.TypeWord64 = unmarshalGet' 8 Data.Binary.Get.getWord64be Data.Binary.Get.getWord64le

unmarshalType T.TypeInt16  = do
	x <- unmarshalGet 2 Data.Binary.Get.getWord16be Data.Binary.Get.getWord16le
	return . T.toValue $ (fromIntegral x :: Int16)

unmarshalType T.TypeInt32  = do
	x <- unmarshalGet 4 Data.Binary.Get.getWord32be Data.Binary.Get.getWord32le
	return . T.toValue $ (fromIntegral x :: Int32)

unmarshalType T.TypeInt64  = do
	x <- unmarshalGet 8 Data.Binary.Get.getWord64be Data.Binary.Get.getWord64le
	return . T.toValue $ (fromIntegral x :: Int64)
:

\clearpage
\subsubsection{Doubles}

{\tt Double}s are marshaled in 64-bit IEEE-754 floating-point format.

:d DBus.Wire
marshalDouble :: Double -> Marshal ()
marshalDouble x = do
	pad 8
	Wire $ \e s -> let
		put = case e of
			BigEndian -> Data.Binary.IEEE754.putFloat64be
			LittleEndian -> Data.Binary.IEEE754.putFloat64le
		bytes = runPut $ put x
		in unWire (appendL bytes) e s
:

:d unmarshalers
unmarshalType T.TypeDouble = unmarshalGet' 8 Data.Binary.IEEE754.getFloat64be Data.Binary.IEEE754.getFloat64le
:

\subsubsection{Booleans}

Booleans are marshaled as 4-byte unsigned integers containing either of
the values 0 or 1. Yes, really.

:d DBus.Wire
marshalBool :: Bool -> Marshal ()
marshalBool = undefined
:

:d unmarshalers
unmarshalType T.TypeBoolean = unmarshalWord32 >>=
	fromMaybeU' "boolean" (\x -> case x of
		0 -> Just False
		1 -> Just True
		_ -> Nothing)
:

\clearpage
\subsubsection{Strings and object paths}

Strings are encoded in {\sc utf-8}, terminated with {\tt NUL}, and prefixed
with their length as an unsigned 32-bit integer. Their alignment is that of
their length. Object paths are marshaled just like strings, though additional
checks are required when unmarshaling.

Because the encoding functions from {\tt Data.Text} raise exceptions on
error, checking their return value requires some ugly workarounds.

:d DBus.Wire.Unicode
excToMaybe :: a -> Maybe a
excToMaybe x = unsafePerformIO $ fmap Just (Exc.evaluate x) `Exc.catch` unicodeError

unicodeError :: UnicodeException -> IO (Maybe a)
unicodeError = const $ return Nothing

maybeEncodeUtf8 :: Text -> Maybe ByteString
maybeEncodeUtf8 = excToMaybe . encodeUtf8

maybeDecodeUtf8 :: ByteString -> Maybe Text
maybeDecodeUtf8 = excToMaybe . decodeUtf8
:

:d DBus.Wire
marshalText :: Text -> Marshal ()
marshalText x = do
	bytes <- case maybeEncodeUtf8 x of
		Just x' -> return x'
		Nothing -> throwError $ InvalidText x
	when (Data.ByteString.any (== 0) bytes) $
		throwError $ InvalidText x
	marshalWord32 . fromIntegral . Data.ByteString.length $ bytes
	appendS bytes
	marshalWord8 0
:

:d DBus.Wire
unmarshalText :: Unmarshal Text
unmarshalText = do
	byteCount <- unmarshalWord32
	bytes <- consume . fromIntegral $ byteCount
	skipTerminator
	fromMaybeU "text" maybeDecodeUtf8 (Data.ByteString.concat (Data.ByteString.Lazy.toChunks bytes))
:

:d DBus.Wire
marshalObjectPath :: T.ObjectPath -> Marshal ()
marshalObjectPath = undefined
:

:d unmarshalers
unmarshalType T.TypeString = liftM T.toValue unmarshalText

unmarshalType T.TypeObjectPath = unmarshalText >>=
	fromMaybeU' "object path" T.objectPath
:

\clearpage
\subsubsection{Signatures}

Signatures are similar to strings, except their length is limited to 255
characters and is therefore stored as a single byte.

:d DBus.Wire
signatureBytes :: T.Signature -> Data.ByteString.ByteString
signatureBytes (T.Signature ts) = Data.ByteString.Char8.pack (concatMap T.typeCode ts)

marshalSignature :: T.Signature -> Marshal ()
marshalSignature x = do
	let bytes = signatureBytes x
	let size = fromIntegral . Data.ByteString.length $ bytes
	marshalWord8 size
	appendS bytes
	marshalWord8 0
:

:d DBus.Wire
unmarshalSignature :: Unmarshal T.Signature
unmarshalSignature = do
	byteCount <- Data.ByteString.Lazy.head `liftM` consume 1
	lazy <- consume $ fromIntegral byteCount
	skipTerminator
	let bytes = Data.ByteString.concat $ Data.ByteString.Lazy.toChunks lazy
	fromMaybeU "signature" T.parseSignature bytes
:

:d unmarshalers
unmarshalType T.TypeSignature = liftM T.toValue unmarshalSignature
:

\clearpage
\subsubsection{Arrays}

:d unmarshalers
unmarshalType t@(T.TypeArray t') = T.ValueVector t `liftM` unmarshalArray t'
:

Marshaling arrays is complicated, because the array body must be marshaled
\emph{first} to calculate the array length. This requires building a
temporary marshaler, to get the padding right.

:d DBus.Wire
arrayMaximumLength :: Word32
arrayMaximumLength = 67108864
:

:d DBus.Wire
marshalVector :: T.Type -> Vector T.Value -> Marshal ()
marshalVector t x = do
	(arrayPadding, arrayBytes) <- getArrayBytes t x
	let arrayLen = Data.ByteString.Lazy.length arrayBytes
	when (arrayLen > fromIntegral arrayMaximumLength)
		(throwError $ ArrayTooLong $ fromIntegral arrayLen)
	marshalWord32 $ fromIntegral arrayLen
	appendL $ Data.ByteString.Lazy.replicate arrayPadding 0
	appendL arrayBytes
:

:d DBus.Wire
getArrayBytes :: T.Type -> Vector T.Value -> Marshal (Int64, Data.ByteString.Lazy.ByteString)
getArrayBytes itemType vs = do
	s <- getState
	(MarshalState _ afterLength) <- marshalWord32 0 >> getState
	(MarshalState _ afterPadding) <- pad (alignment itemType) >> getState
	
	putState $ MarshalState Data.Binary.Builder.empty afterPadding
	(MarshalState itemBuilder _) <- Data.Vector.mapM_ marshal vs >> getState
	
	let itemBytes = Data.Binary.Builder.toLazyByteString itemBuilder
	    paddingSize = fromIntegral $ afterPadding - afterLength
	
	putState s
	return (paddingSize, itemBytes)
:

Unmarshaling is much easier, especially if it's a byte array.

:d DBus.Wire
unmarshalArray :: T.Type -> Unmarshal (Vector T.Value)
unmarshalArray itemType = do
	let getOffset = do
		(UnmarshalState _ o) <- getState
		return o
	byteCount <- unmarshalWord32
	skipPadding (alignment itemType)
	start <- getOffset
	let end = start + fromIntegral byteCount
	vs <- untilM (liftM (>= end) getOffset) (unmarshalType itemType)
	end' <- getOffset
	when (end' > end) $
		throwError ArraySizeMismatch
	return (Data.Vector.fromList vs)
:

\clearpage
\subsubsection{Dictionaries}

:d DBus.Wire
dictionaryToArray :: Map T.Atom T.Value -> Vector T.Value
dictionaryToArray = Data.Vector.fromList . map step . Data.Map.toList where
	step (k, v) = T.ValueStructure [T.ValueAtom k, v]
:

:d DBus.Wire
arrayToDictionary :: Vector T.Value -> Map T.Atom T.Value
arrayToDictionary = Data.Map.fromList . map step . Data.Vector.toList where
	step (T.ValueStructure [T.ValueAtom k, v]) = (k, v)
	step _ = error "arrayToDictionary: internal error"
:

:d DBus.Wire
marshalMap :: T.Type -> Map T.Atom T.Value -> Marshal ()
marshalMap t x = let
	T.TypeDictionary kt vt = t
	structType = T.TypeStructure [kt, vt]
	array = dictionaryToArray x
	in marshalVector structType array
:

:d unmarshalers
unmarshalType t@(T.TypeDictionary kt vt) = do
	let pairType = T.TypeStructure [kt, vt]
	array <- unmarshalArray pairType
	return (T.ValueMap t (arrayToDictionary array))
:

\clearpage
\subsubsection{Structures}

:d DBus.Wire
marshalStructure :: [T.Value] -> Marshal ()
marshalStructure vs = do
	pad 8
	mapM_ marshal vs
:

:d unmarshalers
unmarshalType (T.TypeStructure ts) = do
	skipPadding 8
	liftM T.ValueStructure $ mapM unmarshalType ts
:

\subsubsection{Variants}

:d DBus.Wire
marshalVariant :: T.Variant -> Marshal ()
marshalVariant (T.Variant val) = do
	let textSig = Data.Text.pack (T.typeCode (T.valueType val))
	sig <- case T.signature textSig of
		Just x' -> return x'
		Nothing -> throwError $ InvalidVariantSignature textSig
	marshalSignature sig
	marshal val
:

:d unmarshalers
unmarshalType T.TypeVariant = do
	let getType sig = case T.signatureTypes sig of
		[t] -> Just t
		_   -> Nothing
	
	t <- fromMaybeU "variant signature" getType =<< unmarshalSignature
	(T.toValue . T.Variant) `liftM` unmarshalType t
:


\clearpage
\subsection{Marshaling}

Marshaling is implemented using an error transformer over an internal
state. The {\tt Builder} type is used for efficient construction of lazy
byte strings, but it doesn't provide any way to retrieve the length of its
internal buffer, so the byte count is tracked separately.

Clients can perform marshaling via {\tt marshal} and {\tt runMarshal},
which will generate a {\tt ByteString} with the fully marshaled data.

:d DBus.Wire
runMarshal :: Marshal () -> Endianness -> Either MarshalError Data.ByteString.Lazy.ByteString
runMarshal m e = case unWire m e (MarshalState Data.Binary.Builder.empty 0) of
	WireRL err -> Left err
	WireRR _ (MarshalState builder _) -> Right $ Data.Binary.Builder.toLazyByteString builder
:

TODO: describe these functions

:d DBus.Wire
appendS :: Data.ByteString.ByteString -> Marshal ()
appendS bytes = Wire $ \_ (MarshalState builder count) -> let
	builder' = Data.Binary.Builder.append builder $ Data.Binary.Builder.fromByteString bytes
	count' = count + fromIntegral (Data.ByteString.length bytes)
	in WireRR () (MarshalState builder' count')
:

:d DBus.Wire
appendL :: Data.ByteString.Lazy.ByteString -> Marshal ()
appendL bytes = Wire $ \_ (MarshalState builder count) -> let
	builder' = Data.Binary.Builder.append builder $ Data.Binary.Builder.fromLazyByteString bytes
	count' = count + fromIntegral (Data.ByteString.Lazy.length bytes)
	in WireRR () (MarshalState builder' count')
:

:d DBus.Wire
pad :: Word8 -> Marshal ()
pad count = Wire $ \e s@(MarshalState _ existing) -> let
	padding' = fromIntegral $ padding existing count
	bytes = Data.ByteString.replicate padding' 0
	in unWire (appendS bytes) e s
:

Most numeric values already have marshalers implemented in the
{\tt Data.Binary.Builder} module; this function lets them be re-used easily.

:d DBus.Wire
marshalBuilder :: Word8 -> (a -> Data.Binary.Builder.Builder) -> (a -> Data.Binary.Builder.Builder) -> a -> Marshal ()
marshalBuilder size be le x = do
	pad size
	Wire $ \e (MarshalState builder count) -> let
		builder' = Data.Binary.Builder.append builder $ case e of
			BigEndian -> be x
			LittleEndian -> le x
		size' = fromIntegral size
		in WireRR () (MarshalState builder' (count + size'))
:

\clearpage
\subsection{Unmarshaling}

:d DBus.Wire
runUnmarshal :: Unmarshal a -> Endianness -> Data.ByteString.Lazy.ByteString -> Either UnmarshalError a
runUnmarshal m e bytes = case unWire m e (UnmarshalState bytes 0) of
	WireRL err -> Left err
	WireRR a _ -> Right a
:

:d DBus.Wire
unmarshal :: T.Signature -> Unmarshal [T.Value]
unmarshal = mapM unmarshalType . T.signatureTypes

unmarshalType :: T.Type -> Unmarshal T.Value
|unmarshalers|
:

TODO: describe these functions

:d DBus.Wire
{-# INLINE consume #-}
consume :: Word64 -> Unmarshal Data.ByteString.Lazy.ByteString
consume count = Wire $ \_ (UnmarshalState bytes offset) -> let
	count' = fromIntegral count
	(x, bytes') = Data.ByteString.Lazy.splitAt count' bytes
	in if Data.ByteString.Lazy.length x == count'
		then WireRR x (UnmarshalState bytes' (offset + count))
		else WireRL $ UnexpectedEOF offset
:

:d DBus.Wire
skipPadding :: Word8 -> Unmarshal ()
skipPadding count = do
	(UnmarshalState _ offset) <- getState
	bytes <- consume $ padding offset count
	unless (Data.ByteString.Lazy.all (== 0) bytes) $
		throwError $ InvalidPadding offset
:

:d DBus.Wire
skipTerminator :: Unmarshal ()
skipTerminator = do
	(UnmarshalState _ offset) <- getState
	bytes <- consume 1
	unless (Data.ByteString.Lazy.all (== 0) bytes) $
		throwError $ MissingTerminator offset
:

:d DBus.Wire
fromMaybeU :: Show a => Text -> (a -> Maybe b) -> a -> Unmarshal b
fromMaybeU = fromMaybeU2 show

fromMaybeU2 :: (a -> String) -> Text -> (a -> Maybe b) -> a -> Unmarshal b
fromMaybeU2 show' label f x = case f x of
	Just x' -> return x'
	Nothing -> throwError . Invalid label . Data.Text.pack . show' $ x

fromMaybeU' :: (Show a, T.IsValue b) => Text -> (a -> Maybe b) -> a
           -> Unmarshal T.Value
fromMaybeU' label f x = do
	x' <- fromMaybeU label f x
	return $ T.toValue x'
:

:d DBus.Wire
unmarshalGet :: Word8 -> Data.Binary.Get.Get a -> Data.Binary.Get.Get a -> Unmarshal a
unmarshalGet count be le = do
	skipPadding count
	bs <- consume . fromIntegral $ count
	
	Wire $ \e s -> let
		get = case e of
			BigEndian -> be
			LittleEndian -> le
		in WireRR (Data.Binary.Get.runGet get bs) s

unmarshalGet' :: T.IsValue a => Word8 -> Data.Binary.Get.Get a -> Data.Binary.Get.Get a
              -> Unmarshal T.Value
unmarshalGet' count be le = T.toValue `liftM` unmarshalGet count be le
:

:d DBus.Wire
untilM :: Monad m => m Bool -> m a -> m [a]
untilM test comp = do
	done <- test
	if done
		then return []
		else do
			x <- comp
			xs <- untilM test comp
			return $ x:xs
:

\clearpage
\subsection{Messages}

:d DBus.Wire
protocolVersion :: Word8
protocolVersion = 1

messageMaximumLength :: Word32
messageMaximumLength = 134217728
:

\subsubsection{Flags}

:d DBus.Wire
encodeFlags :: Data.Set.Set M.Flag -> Word8
encodeFlags flags = foldr (.|.) 0 $ map flagValue $ Data.Set.toList flags where
	flagValue M.NoReplyExpected = 0x1
	flagValue M.NoAutoStart     = 0x2
:

:d DBus.Wire
decodeFlags :: Word8 -> Data.Set.Set M.Flag
decodeFlags word = Data.Set.fromList flags where
	flagSet = [ (0x1, M.NoReplyExpected)
	          , (0x2, M.NoAutoStart)
	          ]
	flags = flagSet >>= \(x, y) -> [y | word .&. x > 0]
:

\clearpage
\subsubsection{Header fields}

:d DBus.Wire
encodeField :: M.HeaderField -> T.Value
encodeField (M.Path x)        = encodeField' 1 x
encodeField (M.Interface x)   = encodeField' 2 x
encodeField (M.Member x)      = encodeField' 3 x
encodeField (M.ErrorName x)   = encodeField' 4 x
encodeField (M.ReplySerial x) = encodeField' 5 x
encodeField (M.Destination x) = encodeField' 6 x
encodeField (M.Sender x)      = encodeField' 7 x
encodeField (M.Signature x)   = encodeField' 8 x

encodeField' :: T.IsVariant a => Word8 -> a -> T.Value
encodeField' code x = T.toValue (code, T.toVariant x)
:

:d DBus.Wire
decodeField :: (Word8, T.Variant)
            -> E.ErrorM UnmarshalError [M.HeaderField]
decodeField struct = case struct of
	(1, x) -> decodeField' x M.Path "path"
	(2, x) -> decodeField' x M.Interface "interface"
	(3, x) -> decodeField' x M.Member "member"
	(4, x) -> decodeField' x M.ErrorName "error name"
	(5, x) -> decodeField' x M.ReplySerial "reply serial"
	(6, x) -> decodeField' x M.Destination "destination"
	(7, x) -> decodeField' x M.Sender "sender"
	(8, x) -> decodeField' x M.Signature "signature"
	_      -> return []

decodeField' :: T.IsVariant a => T.Variant -> (a -> b) -> Text
             -> E.ErrorM UnmarshalError [b]
decodeField' x f label = case T.fromVariant x of
	Just x' -> return [f x']
	Nothing -> E.throwErrorM $ InvalidHeaderField label x
:

\clearpage
\subsubsection{Marshaling}

:d DBus.Wire
|apidoc marshalMessage|
marshalMessage :: M.Message a => Endianness -> M.Serial -> a
               -> Either MarshalError Data.ByteString.Lazy.ByteString
marshalMessage e serial msg = runMarshal marshaler e where
	body = M.messageBody msg
	marshaler = do
		sig <- checkBodySig body
		empty <- getState
		mapM_ (marshal . (\(T.Variant x) -> x)) body
		(MarshalState bodyBytesB _) <- getState
		putState empty
		marshalEndianness e
		let bodyBytes = Data.Binary.Builder.toLazyByteString bodyBytesB
		marshalHeader msg serial sig
			$ fromIntegral . Data.ByteString.Lazy.length $ bodyBytes
		pad 8
		appendL bodyBytes
		checkMaximumSize
:

:d DBus.Wire
checkBodySig :: [T.Variant] -> Marshal T.Signature
checkBodySig vs = let
	strSig = concatMap (T.typeCode . T.variantType) vs
	textSig = Data.Text.pack strSig
	bytesSig = Data.ByteString.Char8.pack strSig
	invalid = throwError $ InvalidBodySignature textSig
	in case T.parseSignature bytesSig of
		Just x -> return x
		Nothing -> invalid
:

:d DBus.Wire
marshalHeader :: M.Message a => a -> M.Serial -> T.Signature -> Word32
              -> Marshal ()
marshalHeader msg serial bodySig bodyLength = do
	let fields = M.Signature bodySig : M.messageHeaderFields msg
	marshalWord8 . M.messageTypeCode $ msg
	marshalWord8 . encodeFlags . M.messageFlags $ msg
	marshalWord8 protocolVersion
	marshalWord32 bodyLength
	marshalWord32 . M.serialValue $ serial
	let fieldType = T.TypeStructure [T.TypeWord8, T.TypeVariant]
	marshalVector fieldType (Data.Vector.fromList (map encodeField fields))
:

:d DBus.Wire
marshalEndianness :: Endianness -> Marshal ()
marshalEndianness = marshal . T.toValue . encodeEndianness
:

:d DBus.Wire
checkMaximumSize :: Marshal ()
checkMaximumSize = do
	(MarshalState _ messageLength) <- getState
	when (messageLength > fromIntegral messageMaximumLength)
		(throwError $ MessageTooLong $ fromIntegral messageLength)
:

\clearpage
\subsubsection{Unmarshaling}

:d DBus.Wire
|apidoc unmarshalMessage|
unmarshalMessage :: Monad m => (Word32 -> m Data.ByteString.Lazy.ByteString)
                 -> m (Either UnmarshalError M.ReceivedMessage)
unmarshalMessage getBytes' = E.runErrorT $ do
	let getBytes = E.ErrorT . liftM Right . getBytes'
	
	|read fixed-length header|
	|read full header|
	|read body|
	|build message|
:

The first part of the header has a fixed size of 16 bytes, so it can be
retrieved without any size calculations.

:d read fixed-length header
let fixedSig = "yyyyuuu"
fixedBytes <- getBytes 16
:

The first field of interest is the protocol version; if the incoming
message's version is different from this library, the message cannot be
parsed.

:d read fixed-length header
let messageVersion = Data.ByteString.Lazy.index fixedBytes 3
when (messageVersion /= protocolVersion) $
	E.throwErrorT $ UnsupportedProtocolVersion messageVersion
:

Next is the endianness, used for parsing pretty much every other field.

:d read fixed-length header
let eByte = Data.ByteString.Lazy.index fixedBytes 0
endianness <- case decodeEndianness eByte of
	Just x' -> return x'
	Nothing -> E.throwErrorT . Invalid "endianness" . Data.Text.pack . show $ eByte
:

With the endianness out of the way, the rest of the fixed header
can be decoded

:d read fixed-length header
let unmarshal' x bytes = case runUnmarshal (unmarshal x) endianness bytes of
	Right x' -> return x'
	Left  e  -> E.throwErrorT e
fixed <- unmarshal' fixedSig fixedBytes
let typeCode = fromJust . T.fromValue $ fixed !! 1
let flags = decodeFlags . fromJust . T.fromValue $ fixed !! 2
let bodyLength = fromJust . T.fromValue $ fixed !! 4
let serial = fromJust . T.fromVariant $ T.Variant (fixed !! 5)
:

The last field of the fixed header is actually part of the field array,
but is treated as a single {\tt Word32} so it'll be known how many bytes
to retrieve.

:d read fixed-length header
let fieldByteCount = fromJust . T.fromValue $ fixed !! 6
:

With the field byte count, the remainder of the header bytes can be
pulled out of the monad.

:d read full header
let headerSig  = "yyyyuua(yv)"
fieldBytes <- getBytes fieldByteCount
let headerBytes = Data.ByteString.Lazy.append fixedBytes fieldBytes
header <- unmarshal' headerSig headerBytes
:

And the header fields can be parsed.

:d read full header
let fieldArray = Data.Vector.toList (fromJust . T.fromValue $ header !! 6)
fields <- case E.runErrorM $ concat `liftM` mapM decodeField fieldArray of
	Left err -> E.throwErrorT err
	Right x -> return x
:

The body is always aligned to 8 bytes, so pull out the padding before
unmarshaling it.

:d read body
let bodyPadding = padding (fromIntegral fieldByteCount + 16) 8
void (getBytes (fromIntegral bodyPadding))
:

:d DBus.Wire
findBodySignature :: [M.HeaderField] -> T.Signature
findBodySignature fields = fromMaybe "" signature where
	signature = listToMaybe [x | M.Signature x <- fields]
:

:d read body
let bodySig = findBodySignature fields
:

Then pull the body bytes, and unmarshal it.

:d read body
bodyBytes <- getBytes bodyLength
body <- unmarshal' bodySig bodyBytes
:

Even if the received message was structurally valid, building the
{\tt ReceivedMessage} can still fail due to missing header fields.

:d build message
y <- case E.runErrorM $ buildReceivedMessage typeCode fields of
	Right x -> return x
	Left err -> E.throwErrorT $ MissingHeaderField err
return $ y serial flags (map T.Variant body)
:

This really belongs in the Message section...

:d DBus.Wire
buildReceivedMessage :: Word8 -> [M.HeaderField] -> E.ErrorM Text
                        (M.Serial -> (Data.Set.Set M.Flag) -> [T.Variant]
                         -> M.ReceivedMessage)
:

Method calls

:d DBus.Wire
buildReceivedMessage 1 fields = do
	path <- require "path" [x | M.Path x <- fields]
	member <- require "member name" [x | M.Member x <- fields]
	return $ \serial flags body -> let
		iface = listToMaybe [x | M.Interface x <- fields]
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.MethodCall path member iface dest flags body
		in M.ReceivedMethodCall serial sender msg
:

Method returns

:d DBus.Wire
buildReceivedMessage 2 fields = do
	replySerial <- require "reply serial" [x | M.ReplySerial x <- fields]
	return $ \serial _ body -> let
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.MethodReturn replySerial dest body
		in M.ReceivedMethodReturn serial sender msg
:

Errors

:d DBus.Wire
buildReceivedMessage 3 fields = do
	name <- require "error name" [x | M.ErrorName x <- fields]
	replySerial <- require "reply serial" [x | M.ReplySerial x <- fields]
	return $ \serial _ body -> let
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.Error name replySerial dest body
		in M.ReceivedError serial sender msg
:

Signals

:d DBus.Wire
buildReceivedMessage 4 fields = do
	path <- require "path" [x | M.Path x <- fields]
	member <- require "member name" [x | M.Member x <- fields]
	iface <- require "interface" [x | M.Interface x <- fields]
	return $ \serial _ body -> let
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.Signal path member iface dest body
		in M.ReceivedSignal serial sender msg
:

Unknown

:d DBus.Wire
buildReceivedMessage typeCode fields = return $ \serial flags body -> let
	sender = listToMaybe [x | M.Sender x <- fields]
	msg = M.Unknown typeCode flags body
	in M.ReceivedUnknown serial sender msg
:

:d DBus.Wire
require :: Text -> [a] -> E.ErrorM Text a
require _     (x:_) = return x
require label _     = E.throwErrorM label
:
