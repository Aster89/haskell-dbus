% Copyright (C) 2009 John Millikin <jmillikin@gmail.com>
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

@
\section{Wire format}

<<DBus/Wire.hs>>=
<<copyright>>
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DeriveDataTypeable #-}
module DBus.Wire (<<exports>>) where

import Control.Monad (when, unless)
import qualified Control.Monad.State as ST
import qualified Control.Monad.Error as E
import qualified Data.Binary.Put as P
import qualified Data.Binary.Get as G
import qualified Data.Binary.IEEE754 as IEEE
import qualified Data.ByteString.Lazy as L
import Data.ByteString.Lazy.UTF8 (toString, fromString)
import Data.Bits ((.|.), (.&.))
import Data.Maybe (fromJust, listToMaybe, fromMaybe)
import Data.Word (Word8, Word32, Word64)
import Data.Int (Int16, Int32, Int64)
import Data.Typeable (Typeable)
import qualified Data.Set as Set

import qualified DBus.Constants as C
import qualified DBus.Message as M
import qualified DBus.Types as T

@ \subsection{Endianness}

<<DBus/Wire.hs>>=
data Endianness = LittleEndian | BigEndian
	deriving (Show, Eq)

encodeEndianness :: Endianness -> Word8
encodeEndianness LittleEndian = 108
encodeEndianness BigEndian    = 66

decodeEndianness :: Word8 -> Maybe Endianness
decodeEndianness 108 = Just LittleEndian
decodeEndianness 66  = Just BigEndian
decodeEndianness _   = Nothing

<<exports>>=
  Endianness (..)

@ \subsection{Alignment}

Every built-in type has an associated alignment. If a value of the given
type is marshaled, it must have {\sc nul} bytes inserted until it starts
on a byte index divisible by its alignment.

<<DBus/Wire.hs>>=
alignment :: T.Type -> Word8
<<alignments>>

padding :: Word64 -> Word8 -> Word64
padding current count = required where
	count' = fromIntegral count
	missing = mod current count'
	required = if missing > 0
		then count' - missing
		else 0

<<exports>>=
, alignment

@ \subsection{Marshaling}

Marshaling is implemented using an error transformer over an internal
state.

<<DBus/Wire.hs>>=
data MarshalState = MarshalState Endianness L.ByteString
newtype MarshalM a = MarshalM (E.ErrorT MarshalError (ST.State MarshalState) a)
	deriving (Monad, E.MonadError MarshalError, ST.MonadState MarshalState)
type Marshal = MarshalM ()

@ Clients can perform marshaling via {\tt marshal} and {\tt runMarshal},
which will generate a {\tt ByteString} with the fully marshaled data.

<<exports>>=
, MarshalM
, Marshal
, marshal
, runMarshal

<<DBus/Wire.hs>>=
runMarshal :: Marshal -> Endianness -> Either MarshalError L.ByteString
runMarshal (MarshalM m) e = case ST.runState (E.runErrorT m) initialState of
	(Right _, MarshalState _ bytes) -> Right bytes
	(Left  x, _) -> Left x
	where initialState = MarshalState e L.empty

<<DBus/Wire.hs>>=
marshal :: T.Variant -> Marshal
marshal v = marshalType (T.variantType v) where
	x :: T.Variable a => a
	x = fromJust . T.fromVariant $ v
	marshalType :: T.Type -> Marshal
	<<marshalers>>

@ TODO: describe these functions

<<DBus/Wire.hs>>=
append :: L.ByteString -> Marshal
append bs = do
	(MarshalState e bs') <- ST.get
	ST.put $ MarshalState e (L.append bs' bs)

<<DBus/Wire.hs>>=
pad :: Word8 -> Marshal
pad count = do
	(MarshalState _ bytes) <- ST.get
	let padding' = padding (fromIntegral . L.length $ bytes) count
	append $ L.replicate (fromIntegral padding') 0

@ Most numeric values already have marshalers implemented in the
{\tt Data.Binary.Put} module; this function lets them be re-used easily.

<<DBus/Wire.hs>>=
marshalPut :: (a -> P.Put) -> a -> Marshal
marshalPut put x = do
	let bytes = P.runPut $ put x
	(MarshalState e _) <- ST.get
	pad . fromIntegral . L.length $ bytes
	append $ case e of
		BigEndian -> bytes
		LittleEndian -> L.reverse bytes

@ \subsubsection{Errors}

Marshaling can fail for four reasons:

\begin{itemize}
\item The message exceeds the maximum message size of $2^{27}$ bytes.
\item An array in the message exceeds the maximum array size of $2^{26}$ bytes.
\item The body's signature is not valid (for example, more than 255 fields).
\item A variant's signature is not valid -- same causes as an invalid body
      signature.
\end{itemize}

<<DBus/Wire.hs>>=
data MarshalError
	= MessageTooLong Word64
	| ArrayTooLong Word64
	| InvalidBodySignature String
	| InvalidVariantSignature String
	deriving (Eq, Typeable)

instance Show MarshalError where
	show (MessageTooLong x) = concat
		["Message too long (", show x, " bytes)."]
	show (ArrayTooLong x) = concat
		["Array too long (", show x, " bytes)."]
	show (InvalidBodySignature x) = concat
		["Invalid body signature: ", show x]
	show (InvalidVariantSignature x) = concat
		["Invalid variant signature: ", show x]

instance E.Error MarshalError

<<exports>>=
, MarshalError (..)

@ \subsection{Unmarshaling}

Unmarshaling also uses an error transformer and internal state.

<<exports>>=
, Unmarshal
, unmarshal
, runUnmarshal

<<DBus/Wire.hs>>=
data UnmarshalState = UnmarshalState Endianness L.ByteString Word64
newtype Unmarshal a = Unmarshal (E.ErrorT UnmarshalError (ST.State UnmarshalState) a)
	deriving (Monad, Functor, E.MonadError UnmarshalError, ST.MonadState UnmarshalState)

<<DBus/Wire.hs>>=
runUnmarshal :: Unmarshal a -> Endianness -> L.ByteString -> Either UnmarshalError a
runUnmarshal (Unmarshal m) e bytes = ST.evalState (E.runErrorT m) state where
	state = UnmarshalState e bytes 0

<<DBus/Wire.hs>>=
unmarshal :: T.Signature -> Unmarshal [T.Variant]
unmarshal = mapM unmarshalType . T.signatureTypes

unmarshalType :: T.Type -> Unmarshal T.Variant
<<unmarshalers>>

@ TODO: describe these functions

<<DBus/Wire.hs>>=
consume :: Word64 -> Unmarshal L.ByteString
consume count = do
	(UnmarshalState e bytes offset) <- ST.get
	let bytes' = L.drop (fromIntegral offset) bytes
	let x = L.take (fromIntegral count) bytes'
	unless (L.length x == fromIntegral count) $
		E.throwError $ UnexpectedEOF offset
	
	ST.put $ UnmarshalState e bytes (offset + count)
	return x

<<DBus/Wire.hs>>=
skipPadding :: Word8 -> Unmarshal ()
skipPadding count = do
	(UnmarshalState _ _ offset) <- ST.get
	bytes <- consume $ padding offset count
	unless (L.all (== 0) bytes) $
		E.throwError $ InvalidPadding offset

<<DBus/Wire.hs>>=
skipTerminator :: Unmarshal ()
skipTerminator = do
	(UnmarshalState _ _ offset) <- ST.get
	bytes <- consume 1
	unless (L.all (== 0) bytes) $
		E.throwError $ MissingTerminator offset

<<DBus/Wire.hs>>=
fromMaybeU :: Show a => String -> (a -> Maybe b) -> a -> Unmarshal b
fromMaybeU label f x = case f x of
	Just x' -> return x'
	Nothing -> E.throwError $ Invalid label $ show x

fromMaybeU' :: (Show a, T.Variable b) => String -> (a -> Maybe b) -> a
           -> Unmarshal T.Variant
fromMaybeU' label f x = do
	x' <- fromMaybeU label f x
	return $ T.toVariant x'

<<DBus/Wire.hs>>=
unmarshalGet :: Word8 -> G.Get a -> G.Get a -> Unmarshal a
unmarshalGet count be le = do
	skipPadding count
	(UnmarshalState e _ _) <- ST.get
	bs <- consume . fromIntegral $ count
	let get' = case e of
		BigEndian -> be
		LittleEndian -> le
	return $ G.runGet get' bs

unmarshalGet' :: T.Variable a => Word8 -> G.Get a -> G.Get a
              -> Unmarshal T.Variant
unmarshalGet' count be le = fmap T.toVariant $ unmarshalGet count be le

<<DBus/Wire.hs>>=
untilM :: Monad m => m Bool -> m a -> m [a]
untilM test comp = do
	done <- test
	if done
		then return []
		else do
			x <- comp
			xs <- untilM test comp
			return $ x:xs

@ \subsubsection{Errors}

Unmarshaling can fail for four reasons:

\begin{itemize}
\item The message's declared protocol version is unsupported.
\item Unexpected {\sc eof}, when there are less bytes remaining than are
      required.
\item An invalid byte sequence for a given value type.
\item Missing required header fields for the declared message type.
\item Non-zero bytes were found where padding was expected.
\item A string, signature, or object path was not {\sc null}-terminated.
\item An array's size didn't match the number of elements
\end{itemize}

<<DBus/Wire.hs>>=
data UnmarshalError
	= UnsupportedProtocolVersion Word8
	| UnexpectedEOF Word64
	| Invalid String String
	| MissingHeaderField String
	| InvalidHeaderField String T.Variant
	| InvalidPadding Word64
	| MissingTerminator Word64
	| ArraySizeMismatch
	deriving (Eq, Typeable)

instance Show UnmarshalError where
	show (UnsupportedProtocolVersion x) = concat
		["Unsupported protocol version: ", show x]
	show (UnexpectedEOF pos) = concat
		["Unexpected EOF at position ", show pos]
	show (Invalid label x) = concat
		["Invalid ", label, ": ", x]
	show (MissingHeaderField x) = concat
		["Required field " , show x , " is missing."]
	show (InvalidHeaderField x got) = concat
		[ "Invalid header field ", show x, ": ", show got]
	show (InvalidPadding pos) = concat
		["Invalid padding at position ", show pos]
	show (MissingTerminator pos) = concat
		["Missing NUL terminator at position ", show pos]
	show ArraySizeMismatch = "Array size mismatch"

instance E.Error UnmarshalError

<<exports>>=
, UnmarshalError (..)

@ \subsection{Numerics}

Numeric values are fixed-length, and aligned ``naturally'' -- ie, a 4-byte
integer will have a 4-byte alignment.

<<alignments>>=
alignment T.DBusByte    = 1
alignment T.DBusWord16  = 2
alignment T.DBusWord32  = 4
alignment T.DBusWord64  = 8
alignment T.DBusInt16   = 2
alignment T.DBusInt32   = 4
alignment T.DBusInt64   = 8
alignment T.DBusDouble  = 8

@ Because {\tt Word32}s are often used for other types, there's
separate functions for handling them.

<<DBus/Wire.hs>>=
marshalWord32 :: Word32 -> Marshal
marshalWord32 = marshalPut P.putWord32be

unmarshalWord32 :: Unmarshal Word32
unmarshalWord32 = unmarshalGet 4 G.getWord32be G.getWord32le

<<marshalers>>=
marshalType T.DBusByte   = append $ L.singleton x
marshalType T.DBusWord16 = marshalPut P.putWord16be x
marshalType T.DBusWord32 = marshalPut P.putWord32be x
marshalType T.DBusWord64 = marshalPut P.putWord64be x
marshalType T.DBusInt16  = marshalPut P.putWord16be $ fromIntegral (x :: Int16)
marshalType T.DBusInt32  = marshalPut P.putWord32be $ fromIntegral (x :: Int32)
marshalType T.DBusInt64  = marshalPut P.putWord64be $ fromIntegral (x :: Int64)
marshalType T.DBusDouble = marshalPut IEEE.putFloat64be x

<<unmarshalers>>=
unmarshalType T.DBusByte = fmap (T.toVariant . L.head) $ consume 1
unmarshalType T.DBusWord16 = unmarshalGet' 2 G.getWord16be G.getWord16le
unmarshalType T.DBusWord32 = unmarshalGet' 4 G.getWord32be G.getWord32le
unmarshalType T.DBusWord64 = unmarshalGet' 8 G.getWord64be G.getWord64le
unmarshalType T.DBusDouble = unmarshalGet' 8 IEEE.getFloat64be IEEE.getFloat64le

unmarshalType T.DBusInt16  = do
	x <- unmarshalGet 2 G.getWord16be G.getWord16le
	return . T.toVariant $ (fromIntegral x :: Int16)

unmarshalType T.DBusInt32  = do
	x <- unmarshalGet 4 G.getWord32be G.getWord32le
	return . T.toVariant $ (fromIntegral x :: Int32)

unmarshalType T.DBusInt64  = do
	x <- unmarshalGet 8 G.getWord64be G.getWord64le
	return . T.toVariant $ (fromIntegral x :: Int64)

@ \subsection{Booleans}

Booleans are marshaled as 4-byte unsigned integers containing either of
the values 0 or 1. Yes, really.

<<alignments>>=
alignment T.DBusBoolean = 4

<<marshalers>>=
marshalType T.DBusBoolean = marshalWord32 $ if x then 1 else 0

<<unmarshalers>>=
unmarshalType T.DBusBoolean = unmarshalWord32 >>=
	fromMaybeU' "boolean" (\x -> case x of
		0 -> Just False
		1 -> Just True
		_ -> Nothing)

@ \subsection{Strings and object paths}

Strings are encoded in {\sc utf-8}, terminated with {\tt NUL}, and prefixed
with their length as an unsigned 32-bit integer. Their alignment is that of
their length. Object paths are marshaled just like strings, though additional
checks are required when unmarshaling.

<<DBus/Wire.hs>>=
marshalString :: String -> Marshal
marshalString x = do
	let bytes = fromString x
	marshalWord32 . fromIntegral . L.length $ bytes
	append bytes
	append (L.singleton 0)

<<DBus/Wire.hs>>=
unmarshalString :: Unmarshal String
unmarshalString = do
	byteCount <- unmarshalWord32
	bytes <- consume . fromIntegral $ byteCount
	skipTerminator
	return . toString $ bytes

<<alignments>>=
alignment T.DBusString     = 4
alignment T.DBusObjectPath = 4

<<marshalers>>=
marshalType T.DBusString = marshalString x
marshalType T.DBusObjectPath = marshalString . T.strObjectPath $ x

<<unmarshalers>>=
unmarshalType T.DBusString = fmap T.toVariant unmarshalString

unmarshalType T.DBusObjectPath = unmarshalString >>=
	fromMaybeU' "object path" T.mkObjectPath

@ \subsection{Signatures}

Signatures are similar to strings, except their length is limited to 255
characters and is therefore stored as a single byte.

<<DBus/Wire.hs>>=
marshalSignature :: T.Signature -> Marshal
marshalSignature x = do
	let bytes = fromString . T.strSignature $ x
	let size = fromIntegral . L.length $ bytes
	append (L.singleton size)
	append bytes
	append (L.singleton 0)

<<DBus/Wire.hs>>=
unmarshalSignature :: Unmarshal T.Signature
unmarshalSignature = do
	byteCount <- fmap L.head $ consume 1
	sigStr <- fmap toString $ consume . fromIntegral $ byteCount
	skipTerminator
	fromMaybeU "signature" T.mkSignature sigStr

<<alignments>>=
alignment T.DBusSignature  = 1

<<marshalers>>=
marshalType T.DBusSignature = marshalSignature x

<<unmarshalers>>=
unmarshalType T.DBusSignature = fmap T.toVariant unmarshalSignature

@ \subsection{Containers}

@ \subsubsection{Arrays}

<<alignments>>=
alignment (T.DBusArray _) = 4

<<marshalers>>=
marshalType (T.DBusArray _) = marshalArray x

<<unmarshalers>>=
unmarshalType (T.DBusArray t) = fmap T.toVariant $ unmarshalArray t

@ Marshaling arrays is complicated, because the array body must be marshaled
\emph{first} to calculate the array length. This requires building a
temporary marshaler, to get the padding right.

<<DBus/Wire.hs>>=
marshalArray :: T.Array -> Marshal
marshalArray x = do
	(arrayPadding, arrayBytes) <- getArrayBytes x
	let arrayLen = L.length arrayBytes
	when (arrayLen > fromIntegral C.arrayMaximumLength)
		(E.throwError $ ArrayTooLong $ fromIntegral arrayLen)
	marshalWord32 $ fromIntegral arrayLen
	append arrayPadding
	append arrayBytes

<<DBus/Wire.hs>>=
getArrayBytes :: T.Array -> MarshalM (L.ByteString, L.ByteString)
getArrayBytes x = do
	let vs = T.arrayItems x
	let itemType = T.arrayType x
	s <- ST.get
	(MarshalState _ afterLength) <- marshalWord32 0 >> ST.get
	(MarshalState _ afterPadding) <- pad (alignment itemType) >> ST.get
	(MarshalState _ afterItems) <- mapM_ marshal vs >> ST.get
	
	let paddingBytes = L.drop (L.length afterLength) afterPadding
	let itemBytes = L.drop (L.length afterPadding) afterItems
	
	ST.put s
	return (paddingBytes, itemBytes)

@ Unmarshaling is much easier

<<DBus/Wire.hs>>=
unmarshalArray :: T.Type -> Unmarshal T.Array
unmarshalArray itemType = do
	let getOffset = do
		(UnmarshalState _ _ o) <- ST.get
		return o
	byteCount <- unmarshalWord32
	skipPadding (alignment itemType)
	start <- getOffset
	let end = start + fromIntegral byteCount
	vs <- untilM (fmap (>= end) getOffset) (unmarshalType itemType)
	end' <- getOffset
	when (end' > end) $
		E.throwError ArraySizeMismatch
	fromMaybeU "array" (T.arrayFromItems itemType) vs

@ \subsubsection{Dictionaries}

<<alignments>>=
alignment (T.DBusDictionary _ _) = 4

<<marshalers>>=
marshalType (T.DBusDictionary _ _) = marshalArray (T.dictionaryToArray x)

<<unmarshalers>>=
unmarshalType (T.DBusDictionary kt vt) = do
	let pairType = T.DBusStructure [kt, vt]
	array <- unmarshalArray pairType
	fromMaybeU' "dictionary" T.arrayToDictionary array

@ \subsubsection{Structures}

<<alignments>>=
alignment (T.DBusStructure _) = 8

<<marshalers>>=
marshalType (T.DBusStructure _) = do
	let T.Structure vs = x
	pad 8
	mapM_ marshal vs

<<unmarshalers>>=
unmarshalType (T.DBusStructure ts) = do
	skipPadding 8
	fmap (T.toVariant . T.Structure) $ mapM unmarshalType ts

@ \subsubsection{Variants}

<<alignments>>=
alignment T.DBusVariant = 1

<<marshalers>>=
marshalType T.DBusVariant = do
	let rawSig = T.typeCode . T.variantType $ x
	sig <- case T.mkSignature rawSig of
		Just x' -> return x'
		Nothing -> E.throwError $ InvalidVariantSignature rawSig
	marshalSignature sig
	marshal x

<<unmarshalers>>=
unmarshalType T.DBusVariant = do
	let getType sig = case T.signatureTypes sig of
		[t] -> Just t
		_   -> Nothing
	
	t <- fromMaybeU "variant signature" getType =<< unmarshalSignature
	fmap T.toVariant $ unmarshalType t

@ \subsection{Messages}

@ \subsubsection{Flags}

<<DBus/Wire.hs>>=
encodeFlags :: Set.Set M.Flag -> Word8
encodeFlags flags = foldr (.|.) 0 $ map flagValue $ Set.toList flags where
	flagValue M.NoReplyExpected = 0x1
	flagValue M.NoAutoStart     = 0x2

decodeFlags :: Word8 -> Set.Set M.Flag
decodeFlags word = Set.fromList flags where
	flagSet = [ (0x1, M.NoReplyExpected)
	          , (0x2, M.NoAutoStart)
	          ]
	flags = flagSet >>= \(x, y) -> [y | word .&. x > 0]

@ \subsubsection{Header fields}

<<DBus/Wire.hs>>=
encodeField :: M.HeaderField -> T.Structure
encodeField (M.Path x)        = encodeField' 1 x
encodeField (M.Interface x)   = encodeField' 2 x
encodeField (M.Member x)      = encodeField' 3 x
encodeField (M.ErrorName x)   = encodeField' 4 x
encodeField (M.ReplySerial x) = encodeField' 5 x
encodeField (M.Destination x) = encodeField' 6 x
encodeField (M.Sender x)      = encodeField' 7 x
encodeField (M.Signature x)   = encodeField' 8 x

encodeField' :: T.Variable a => Word8 -> a -> T.Structure
encodeField' code x = T.Structure
	[ T.toVariant code
	, T.toVariant $ T.toVariant x
	]

<<DBus/Wire.hs>>=
decodeField :: Monad m => T.Structure
            -> E.ErrorT UnmarshalError m [M.HeaderField]
decodeField struct = case unpackField struct of
	(1, x) -> decodeField' x M.Path "path"
	(2, x) -> decodeField' x M.Interface "interface"
	(3, x) -> decodeField' x M.Member "member"
	(4, x) -> decodeField' x M.ErrorName "error name"
	(5, x) -> decodeField' x M.ReplySerial "reply serial"
	(6, x) -> decodeField' x M.Destination "destination"
	(7, x) -> decodeField' x M.Sender "sender"
	(8, x) -> decodeField' x M.Signature "signature"
	_      -> return []

decodeField' :: (Monad m, T.Variable a) => T.Variant -> (a -> b) -> String
             -> E.ErrorT UnmarshalError m [b]
decodeField' x f label = case T.fromVariant x of
	Just x' -> return [f x']
	Nothing -> E.throwError $ InvalidHeaderField label x

<<DBus/Wire.hs>>=
unpackField :: T.Structure -> (Word8, T.Variant)
unpackField struct = (c', v') where
	T.Structure [c, v] = struct
	c' = fromJust . T.fromVariant $ c
	v' = fromJust . T.fromVariant $ v

@ \subsubsection{Header layout}

TODO: describe header layout here

@ \subsubsection{Marshaling}

<<exports>>=
, marshalMessage

<<DBus/Wire.hs>>=
marshalMessage :: M.Message a => Endianness -> M.Serial -> a
               -> Either MarshalError L.ByteString
marshalMessage e serial msg = runMarshal marshaler e where
	body = M.messageBody msg
	marshaler = do
		sig <- checkBodySig body
		empty <- ST.get
		mapM_ marshal body
		(MarshalState _ bodyBytes) <- ST.get
		ST.put empty
		marshalEndianness e
		marshalHeader msg serial sig
			$ fromIntegral . L.length $ bodyBytes
		pad 8
		append bodyBytes
		checkMaximumSize

checkBodySig :: [T.Variant] -> MarshalM T.Signature
checkBodySig vs = let
	sigStr = concatMap (T.typeCode . T.variantType) vs
	invalid = E.throwError $ InvalidBodySignature sigStr
	in case T.mkSignature sigStr of
		Just x -> return x
		Nothing -> invalid

marshalHeader :: M.Message a => a -> M.Serial -> T.Signature -> Word32
              -> Marshal
marshalHeader msg serial bodySig bodyLength = do
	let fields = M.Signature bodySig : M.messageHeaderFields msg
	marshal . T.toVariant . M.messageTypeCode $ msg
	marshal . T.toVariant . encodeFlags . M.messageFlags $ msg
	marshal . T.toVariant $ C.protocolVersion
	marshalWord32 bodyLength
	marshal . T.toVariant $ serial
	let fieldType = T.DBusStructure [T.DBusByte, T.DBusVariant]
	marshal . T.toVariant . fromJust . T.toArray fieldType
	        $ map encodeField fields

marshalEndianness :: Endianness -> Marshal
marshalEndianness = marshal . T.toVariant . encodeEndianness

checkMaximumSize :: Marshal
checkMaximumSize = do
	(MarshalState _ messageBytes) <- ST.get
	let messageLength = L.length messageBytes
	when (messageLength > fromIntegral C.messageMaximumLength)
		(E.throwError $ MessageTooLong $ fromIntegral messageLength)

@ \subsubsection{Unmarshaling}

<<exports>>=
, unmarshalMessage

<<DBus/Wire.hs>>=
unmarshalMessage :: Monad m => (Word32 -> m L.ByteString)
                 -> m (Either UnmarshalError M.ReceivedMessage)
unmarshalMessage getBytes' = E.runErrorT $ do
	let getBytes = E.lift . getBytes'
	
	<<read fixed-length header>>
	<<read full header>>
	<<read body>>
	<<build message>>

@ The first part of the header has a fixed size of 16 bytes, so it can be
retrieved without any size calculations.

<<read fixed-length header>>=
let fixedSig = T.mkSignature' "yyyyuuu"
fixedBytes <- getBytes 16

@ The first field of interest is the protocol version; if the incoming
message's version is different from this library, the message cannot be
parsed.

<<read fixed-length header>>=
let messageVersion = L.index fixedBytes 3
when (messageVersion /= C.protocolVersion) $
	E.throwError $ UnsupportedProtocolVersion messageVersion

@ Next is the endianness, used for parsing pretty much every other field.

<<read fixed-length header>>=
let eByte = L.index fixedBytes 0
endianness <- case decodeEndianness eByte of
	Just x' -> return x'
	Nothing -> E.throwError $ Invalid "endianness" $ show eByte

@ With the endianness out of the way, the rest of the fixed header
can be decoded

<<read fixed-length header>>=
let unmarshal' x bytes = case runUnmarshal (unmarshal x) endianness bytes of
	Right x' -> return x'
	Left  e  -> E.throwError e
fixed <- unmarshal' fixedSig fixedBytes
let typeCode = fromJust . T.fromVariant $ fixed !! 1
let flags = decodeFlags . fromJust . T.fromVariant $ fixed !! 2
let bodyLength = fromJust . T.fromVariant $ fixed !! 4
let serial = fromJust . T.fromVariant $ fixed !! 5

@ The last field of the fixed header is actually part of the field array,
but is treated as a single {\tt Word32} so it'll be known how many bytes
to retrieve.

<<read fixed-length header>>=
let fieldByteCount = fromJust . T.fromVariant $ fixed !! 6

@ With the field byte count, the remainder of the header bytes can be
pulled out of the monad.

<<read full header>>=
let headerSig  = T.mkSignature' "yyyyuua(yv)"
fieldBytes <- getBytes fieldByteCount
let headerBytes = L.append fixedBytes fieldBytes
header <- unmarshal' headerSig headerBytes

@ And the header fields can be parsed.

<<read full header>>=
let fieldArray = fromJust . T.fromVariant $ header !! 6
let fieldStructures = fromJust . T.fromArray $ fieldArray
fields <- fmap concat $ mapM decodeField fieldStructures

@ The body is always aligned to 8 bytes, so pull out the padding before
unmarshaling it.

<<read body>>=
let bodyPadding = padding (fromIntegral fieldByteCount + 16) 8
getBytes . fromIntegral $ bodyPadding

<<DBus/Wire.hs>>=
findBodySignature :: [M.HeaderField] -> T.Signature
findBodySignature fields = fromMaybe empty signature where
	empty = T.mkSignature' ""
	signature = listToMaybe [x | M.Signature x <- fields]

<<read body>>=
let bodySig = findBodySignature fields

@ Then pull the body bytes, and unmarshal it.

<<read body>>=
bodyBytes <- getBytes bodyLength
body <- unmarshal' bodySig bodyBytes

@ Even if the received message was structurally valid, building the
{\tt ReceivedMessage} can still fail due to missing header fields.

<<build message>>=
y <- case buildReceivedMessage typeCode fields of
	Right x -> return x
	Left x -> E.throwError $ MissingHeaderField x

<<build message>>=
return $ y serial flags body

@ This really belongs in the Message section...

<<DBus/Wire.hs>>=
buildReceivedMessage :: Word8 -> [M.HeaderField] -> Either String 
                        (M.Serial -> (Set.Set M.Flag) -> [T.Variant]
                         -> M.ReceivedMessage)

@ Method calls

<<DBus/Wire.hs>>=
buildReceivedMessage 1 fields = do
	path <- require "path" [x | M.Path x <- fields]
	member <- require "member name" [x | M.Member x <- fields]
	return $ \serial flags body -> let
		iface = listToMaybe [x | M.Interface x <- fields]
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.MethodCall path member iface dest flags body
		in M.ReceivedMethodCall serial sender msg

@ Method returns

<<DBus/Wire.hs>>=
buildReceivedMessage 2 fields = do
	replySerial <- require "reply serial" [x | M.ReplySerial x <- fields]
	return $ \serial flags body -> let
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.MethodReturn replySerial dest flags body
		in M.ReceivedMethodReturn serial sender msg

@ Errors

<<DBus/Wire.hs>>=
buildReceivedMessage 3 fields = do
	name <- require "error name" [x | M.ErrorName x <- fields]
	replySerial <- require "reply serial" [x | M.ReplySerial x <- fields]
	return $ \serial flags body -> let
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.Error name replySerial dest flags body
		in M.ReceivedError serial sender msg

@ Signals

<<DBus/Wire.hs>>=
buildReceivedMessage 4 fields = do
	path <- require "path" [x | M.Path x <- fields]
	member <- require "member name" [x | M.Member x <- fields]
	iface <- require "interface" [x | M.Interface x <- fields]
	return $ \serial flags body -> let
		dest = listToMaybe [x | M.Destination x <- fields]
		sender = listToMaybe [x | M.Sender x <- fields]
		msg = M.Signal path member iface dest flags body
		in M.ReceivedSignal serial sender msg

@ Unknown

<<DBus/Wire.hs>>=
buildReceivedMessage typeCode fields = return $ \serial flags body -> let
	sender = listToMaybe [x | M.Sender x <- fields]
	msg = M.Unknown typeCode fields flags body
	in M.ReceivedUnknown serial sender msg

<<DBus/Wire.hs>>=
require :: String -> [a] -> Either String a
require _     (x:_) = Right x
require label _     = Left label
