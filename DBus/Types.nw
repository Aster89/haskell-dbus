% Copyright (C) 2009 John Millikin <jmillikin@gmail.com>
% 
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

@
\section{Types}

<<DBus/Types.hs>>=
<<copyright>>
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE TypeSynonymInstances #-}
module DBus.Types (<<exports>>) where

import Control.Arrow ((***))
import Control.Monad (forM, unless, msum)
import Data.Word (Word8, Word16, Word32, Word64)
import Data.Int (Int16, Int32, Int64)
import Data.List (intercalate)
import qualified Data.Map as Map
import Data.Typeable (Typeable, cast)
import qualified Data.Text as T
import qualified Data.Text.Lazy as TL
import Text.Parsec ((<|>))
import qualified Text.Parsec as P
import DBus.Util (checkLength, parseMaybe, mkUnsafe)

@ DBus types are divided into two categories, ``atomic'' and ``container''
types. Atoms are actual values -- strings, numbers, etc. Containers store
atoms and other containers. The most interesting difference between the two
is that atoms may be used as the keys in associative mappings
(``dictionaries'').

Internally, types are represented using an enumerated type.

<<DBus/Types.hs>>=
data Type
	= DBusBoolean
	| DBusByte
	| DBusInt16
	| DBusInt32
	| DBusInt64
	| DBusWord16
	| DBusWord32
	| DBusWord64
	| DBusDouble
	| DBusString
	| DBusSignature
	| DBusObjectPath
	| DBusVariant
	| DBusArray Type
	| DBusDictionary Type Type
	| DBusStructure [Type]
	deriving (Show, Eq)

class Typeable a => Builtin a where
	builtinDBusType :: a -> Type

typeCode :: Type -> String
<<atomic type codes>>
<<container type codes>>

<<exports>>=
  Type (..)
, typeCode

@ \subsection{Atoms}

Every atomic type is identified by a unique ``type code'', which is a single
letter.

\begin{table}[h]
\caption{Atomic types}
\begin{center}
\begin{tabular}{lll}
\toprule
Type        & Code & Description \\
\midrule
Boolean     &  b   & Either {\tt True} or {\tt False} \\
Byte        &  y   & 8-bit unsigned integer \\
Int16       &  n   & 16-bit signed integer \\
Int32       &  i   & 32-bit signed integer \\
Int64       &  x   & 64-bit signed integer \\
Word16      &  q   & 16-bit unsigned integer \\
Word32      &  u   & 32-bit unsigned integer \\
Word64      &  t   & 64-bit unsigned integer \\
Double      &  d   & 64-bit IEEE754 floating-point \\
String      &  s   & Unicode string with no {\tt NUL} bytes \\
Signature   &  g   & Type signature; see ``Signatures'' \\
Object path &  o   & Path to a remote object; see ``Object paths'' \\
\bottomrule
\end{tabular}
\end{center}
\end{table}

<<atomic type codes>>=
typeCode DBusBoolean    = "b"
typeCode DBusByte       = "y"
typeCode DBusInt16      = "n"
typeCode DBusInt32      = "i"
typeCode DBusInt64      = "x"
typeCode DBusWord16     = "q"
typeCode DBusWord32     = "u"
typeCode DBusWord64     = "t"
typeCode DBusDouble     = "d"
typeCode DBusString     = "s"
typeCode DBusSignature  = "g"
typeCode DBusObjectPath = "o"

<<DBus/Types.hs>>=
isAtomicType :: Type -> Bool
isAtomicType DBusBoolean    = True
isAtomicType DBusByte       = True
isAtomicType DBusInt16      = True
isAtomicType DBusInt32      = True
isAtomicType DBusInt64      = True
isAtomicType DBusWord16     = True
isAtomicType DBusWord32     = True
isAtomicType DBusWord64     = True
isAtomicType DBusDouble     = True
isAtomicType DBusString     = True
isAtomicType DBusSignature  = True
isAtomicType DBusObjectPath = True
isAtomicType _              = False

@ The {\tt Atom} type is used to store any type which must be atomic, such
as dictionary keys. The constructor is not exported outside of this module,
so clients aren't allowed to invent their own atomic types.

<<DBus/Types.hs>>=
class Variable a => Atomic a where
	toAtom   :: a -> Atom
	fromAtom :: Atom -> Maybe a

data Atom = forall a. (Builtin a, Atomic a, Show a, Eq a) => Atom a

instance Show Atom where
	showsPrec d (Atom x) = showParen (d > 10) $
		s "Atom " . showSig . s " " . showsPrec 11 x
		where showSig = shows . typeCode . builtinDBusType $ x
		      s       = showString

instance Eq Atom where
	(Atom x) == (Atom y) = cast x == Just y

atomType :: Atom -> Type
atomType (Atom x) = builtinDBusType x

<<exports>>=
, Atom
, Atomic (..)
, atomType

@ Most atomic types map directly to a built-in Haskell type.

<<DBus/Types.hs>>=
#define BUILTIN_ATOMIC(HASKELL, DBUS) \
	instance Builtin HASKELL where \
		{ builtinDBusType _ = DBUS }; \
	instance Atomic HASKELL where \
		{ toAtom = Atom \
		; fromAtom (Atom x) = cast x };

BUILTIN_ATOMIC(Bool,   DBusBoolean)
BUILTIN_ATOMIC(Word8,  DBusByte)
BUILTIN_ATOMIC(Int16,  DBusInt16)
BUILTIN_ATOMIC(Int32,  DBusInt32)
BUILTIN_ATOMIC(Int64,  DBusInt64)
BUILTIN_ATOMIC(Word16, DBusWord16)
BUILTIN_ATOMIC(Word32, DBusWord32)
BUILTIN_ATOMIC(Word64, DBusWord64)
BUILTIN_ATOMIC(Double, DBusDouble)

@ Strings are a weird case; the built-in type, {\tt String}, is horribly
inefficent. To provide better performance for large strings, the types
defined in {\tt Data.Text} are used internally.

There's two different {\tt Text} types, strict and lazy, so instances
are added for each. Only lazy {\tt Text} values are actually stored; other
text-like types are converted.

<<DBus/Types.hs>>=
BUILTIN_ATOMIC(TL.Text, DBusString)

instance Atomic T.Text where
	toAtom = toAtom . TL.fromChunks . (:[])
	fromAtom = fmap (T.concat . TL.toChunks) . fromAtom

@ Built-in {\tt String}s can still be stored, of course.

<<DBus/Types.hs>>=
instance Atomic String where
	toAtom = toAtom . TL.pack
	fromAtom = fmap TL.unpack . fromAtom

@ A few types are DBus-specific; they are defined later.

<<DBus/Types.hs>>=
BUILTIN_ATOMIC(Signature, DBusSignature)
BUILTIN_ATOMIC(ObjectPath, DBusObjectPath)

@ \subsection{Containers}
Container types are identified by a (generally) multi-character type code,
depending in which types they contain. There are four kinds of containers:

@ \subsubsection{Variants}

Variants may store any DBus value, including other variants. Their type code
is ``v'', which does not change depending on the type they contain. Variants
can be used to store heterogenous values in an array or dictionary.

<<container type codes>>=
typeCode DBusVariant = "v"

<<DBus/Types.hs>>=
class Variable a where
	toVariant :: a -> Variant
	fromVariant :: Variant -> Maybe a

data Variant = forall a. (Builtin a, Show a, Eq a) => Variant a
	deriving (Typeable)

instance Show Variant where
	showsPrec d (Variant x) = showParen (d > 10) $
		s "Variant " . showSig . s " " . showsPrec 11 x
		where showSig = shows . typeCode . builtinDBusType $ x
		      s       = showString

instance Eq Variant where
	(Variant x) == (Variant y) = cast x == Just y

instance Builtin Variant where
	builtinDBusType _ = DBusVariant

@ Any instance of {\tt Variable} can be stored in a {\tt Variant}.
``Built-in'' types, defined below, have direct access to the {\tt Variant}
value constructor. Other types may implement {\tt toVariant} by constructing
a {\tt Variant} containing a built-in type.

<<DBus/Types.hs>>=
variantType :: Variant -> Type
variantType (Variant x) = builtinDBusType x

atomToVariant :: Atom -> Variant
atomToVariant (Atom x) = toVariant x

variantToAtom :: Variant -> Maybe Atom
variantToAtom v = msum as where
	v' :: Variable a => Maybe a
	v' = fromVariant v
	fa :: (Atomic a, Functor f) => f a -> f Atom
	fa = fmap toAtom
	
	as = [fa (v' :: Maybe Bool)
	     ,fa (v' :: Maybe Word8)
	     ,fa (v' :: Maybe Word16)
	     ,fa (v' :: Maybe Word32)
	     ,fa (v' :: Maybe Word64)
	     ,fa (v' :: Maybe Int16)
	     ,fa (v' :: Maybe Int32)
	     ,fa (v' :: Maybe Int64)
	     ,fa (v' :: Maybe Double)
	     ,fa (v' :: Maybe TL.Text)
	     ,fa (v' :: Maybe ObjectPath)
	     ,fa (v' :: Maybe Signature)
	     ]

@ By default, there are instances of {\tt Variable} for all built-in types.

<<DBus/Types.hs>>=
#define BUILTIN_VARIABLE(T) \
	instance Variable T where \
		{ toVariant = Variant \
		; fromVariant (Variant x) = cast x }

BUILTIN_VARIABLE(Bool)
BUILTIN_VARIABLE(Word8)
BUILTIN_VARIABLE(Int16)
BUILTIN_VARIABLE(Int32)
BUILTIN_VARIABLE(Int64)
BUILTIN_VARIABLE(Word16)
BUILTIN_VARIABLE(Word32)
BUILTIN_VARIABLE(Word64)
BUILTIN_VARIABLE(Double)
BUILTIN_VARIABLE(TL.Text)
BUILTIN_VARIABLE(Signature)
BUILTIN_VARIABLE(ObjectPath)
BUILTIN_VARIABLE(Variant)

<<DBus/Types.hs>>=
instance Variable T.Text where
	toVariant = toVariant . TL.fromChunks . (:[])
	fromVariant = fmap (T.concat . TL.toChunks) . fromVariant

instance Variable String where
	toVariant = toVariant . TL.pack
	fromVariant = fmap TL.unpack . fromVariant

<<exports>>=
, Variant
, Variable (..)
, variantType
, atomToVariant

@ \subsubsection{Arrays}

Arrays are homogenous sequences of any valid DBus type. An array's type
code is ``a'' followed by the type it contains. For example, an array of
booleans would have the type string ``ab''.

TODO: There ought to be a specialised constructor for arrays of bytes, based
on the {\tt ByteString} type. Storing bytes individually in a list of
{\tt Variant}s is insane.

<<container type codes>>=
typeCode (DBusArray t) = 'a' : typeCode t

<<DBus/Types.hs>>=
data Array = Array Type [Variant]
	deriving (Eq, Typeable)

instance Show Array where
	showsPrec d (Array t vs) = showParen (d > 10) $
		s "Array " . showSig . s " [" . s valueString . s "]" where
			s = showString
			showSig = shows $ typeCode t
			vs' = [show x | (Variant x) <- vs]
			valueString = intercalate ", " vs'

instance Builtin Array where
	builtinDBusType (Array t _) = DBusArray t

BUILTIN_VARIABLE(Array)

arrayType :: Array -> Type
arrayType (Array t _) = t

arrayItems :: Array -> [Variant]
arrayItems (Array _ vs) = vs

fromArray :: Variable a => Array -> Maybe [a]
fromArray (Array _ vs) = mapM fromVariant vs

toArray :: Variable a => Type -> [a] -> Maybe Array
toArray t = arrayFromItems t . map toVariant

arrayFromItems :: Type -> [Variant] -> Maybe Array
arrayFromItems t vs = do
	mkSignature (typeCode t)
	if all (\x -> variantType x == t) vs
		then Just $ Array t vs
		else Nothing

<<exports>>=
, Array
, arrayType
, arrayItems
, fromArray
, toArray
, arrayFromItems

@ \subsubsection{Dictionaries}

A homogenous (key $\rightarrow$ value) mapping, where the key type must be
atomic. Values may be of any valid DBus type, but must have an identical
type. A dictionary's type code is ``a\{$key\_type$ $value\_type$\}''. For
example, a dictionary of bytes to booleans would have the type string
``a{yb}''.

<<container type codes>>=
typeCode (DBusDictionary k v) = concat ["a{", typeCode k, typeCode v, "}"]

<<DBus/Types.hs>>=
data Dictionary = Dictionary Type Type [(Atom, Variant)]
	deriving (Eq, Typeable)

instance Show Dictionary where
	showsPrec d (Dictionary kt vt pairs) = showParen (d > 10) $
		s "Dictionary " . showSig . s " {" . s valueString . s "}" where
			s = showString
			showSig = shows (typeCode kt ++ typeCode vt)
			valueString = intercalate ", " $ map showPair pairs
			showPair ((Atom k), (Variant v)) =
				show k ++ " -> " ++ show v

instance Builtin Dictionary where
	builtinDBusType (Dictionary kt vt _) = DBusDictionary kt vt

BUILTIN_VARIABLE(Dictionary)

dictionaryKeyType :: Dictionary -> Type
dictionaryKeyType (Dictionary t _ _) = t

dictionaryValueType :: Dictionary -> Type
dictionaryValueType (Dictionary _ t _) = t

dictionaryItems :: Dictionary -> [(Atom, Variant)]
dictionaryItems (Dictionary _ _ vs) = vs

fromDictionary :: (Atomic a, Ord a, Variable b) => Dictionary
               -> Maybe (Map.Map a b)
fromDictionary (Dictionary _ _ vs) = do
	pairs <- forM vs $ \(k, v) -> do
		k' <- fromAtom k
		v' <- fromVariant v
		return (k', v')
	return $ Map.fromList pairs

toDictionary :: (Atomic a, Variable b) => Type -> Type -> Map.Map a b
             -> Maybe Dictionary
toDictionary kt vt map' = dictionaryFromItems kt vt pairs where
	pairs = map (toAtom *** toVariant) $ Map.toList map'

dictionaryFromItems :: Type -> Type -> [(Atom, Variant)] -> Maybe Dictionary
dictionaryFromItems kt vt pairs = do
	unless (isAtomicType kt) Nothing
	mkSignature (typeCode kt)
	mkSignature (typeCode vt)
	
	let sameType (k, v) = atomType k == kt && variantType v == vt
	if all sameType pairs
		then Just $ Dictionary kt vt pairs
		else Nothing

dictionaryToArray :: Dictionary -> Array
dictionaryToArray (Dictionary kt vt items) = array where
	Just array = arrayFromItems itemType $ map toVariant structs
	itemType = DBusStructure [kt, vt]
	structs = [Structure [atomToVariant k, v] | (k, v) <- items]

arrayToDictionary :: Array -> Maybe Dictionary
arrayToDictionary (Array t items) = do
	let toPair v = do
		struct <- fromVariant v
		case struct of
			Structure [k, v'] -> do
				k' <- variantToAtom k
				return (k', v')
			_                -> Nothing
	(kt, vt) <- case t of
		DBusStructure [kt, vt] -> Just (kt, vt)
		_                      -> Nothing
	pairs <- mapM toPair items
	dictionaryFromItems kt vt pairs

<<exports>>=
, Dictionary
, dictionaryItems
, dictionaryKeyType
, dictionaryValueType
, fromDictionary
, toDictionary
, dictionaryFromItems
, dictionaryToArray
, arrayToDictionary

@ \subsubsection{Structures}

A heterogeneous, fixed-length structure; equivalent in purpose to a Haskell
tuple. A structure's type code is the concatenation of its contained types,
wrapped by ``('' and ``)''. Structures may be empty, in which case their
type code is simply ``()''.

<<container type codes>>=
typeCode (DBusStructure ts) = "(" ++ concatMap typeCode ts ++ ")"

<<DBus/Types.hs>>=
data Structure = Structure [Variant]
	deriving (Show, Eq, Typeable)

instance Builtin Structure where
	builtinDBusType (Structure vs) = DBusStructure $ map variantType vs

BUILTIN_VARIABLE(Structure)

<<exports>>=
, Structure (..)

@ \subsection{Signatures}

@ Valid DBus type signatures must obey certain rules, such as ``dict keys
must be atomic'', which are difficult to express in the Haskell type system.
A signature is guaranteed to be valid according to these rules. Creating them
requires using the {\tt mkSignature} function, which will convert a valid
DBus signature string into a {\tt Signature}.

<<DBus/Types.hs>>=
data Signature = Signature { signatureTypes :: [Type] }
	deriving (Eq, Typeable)

instance Show Signature where
	showsPrec d x = showParen (d > 10) $
		showString "Signature " . shows (strSignature x)

strSignature :: Signature -> String
strSignature (Signature ts) = concatMap typeCode ts

@ Additional restrictions apply to signatures, in addition to those imposed
by the DBus type definitions:

\begin{itemize}
\item Signatures may be at most 255 characters long.
\end{itemize}

<<DBus/Types.hs>>=
mkSignature :: String -> Maybe Signature
mkSignature = (parseMaybe sigParser =<<) . checkLength 255 where
	sigParser = do
		types <- P.many parseType
		P.eof
		return $ Signature types
	parseType = parseAtom <|> parseContainer
	parseContainer =
		    parseArray
		<|> parseStruct
		<|> (P.char 'v' >> return DBusVariant)
	parseAtom =
		    (P.char 'b' >> return DBusBoolean)
		<|> (P.char 'y' >> return DBusByte)
		<|> (P.char 'n' >> return DBusInt16)
		<|> (P.char 'i' >> return DBusInt32)
		<|> (P.char 'x' >> return DBusInt64)
		<|> (P.char 'q' >> return DBusWord16)
		<|> (P.char 'u' >> return DBusWord32)
		<|> (P.char 't' >> return DBusWord64)
		<|> (P.char 'd' >> return DBusDouble)
		<|> (P.char 's' >> return DBusString)
		<|> (P.char 'g' >> return DBusSignature)
		<|> (P.char 'o' >> return DBusObjectPath)
	parseArray = do
		P.char 'a'
		parseDict <|> do
		t <- parseType
		return $ DBusArray t
	parseDict = do
		P.char '{'
		keyType <- parseAtom
		valueType <- parseType
		P.char '}'
		return $ DBusDictionary keyType valueType
	parseStruct = do
		P.char '('
		types <- P.many parseType
		P.char ')'
		return $ DBusStructure types

@ Since many signatures are defined as string literals, it's useful to
have a helper function to construct a signature directly from a string.
If the input string is invalid, {\tt error} will be called.

<<DBus/Types.hs>>=
mkSignature' :: String -> Signature
mkSignature' = mkUnsafe "signature" mkSignature

@ Most of these are available for use by clients, with the exception of the
{\tt Signature} value constructor.

<<exports>>=
, Signature
, signatureTypes
, strSignature
, mkSignature
, mkSignature'

@ \subsection{Object paths}

<<DBus/Types.hs>>=
newtype ObjectPath = ObjectPath String
	deriving (Show, Eq, Ord, Typeable)

strObjectPath :: ObjectPath -> String
strObjectPath (ObjectPath x) = x

@ An object path may be one of

\begin{itemize}
\item The root path, {\tt "/"}.
\item {\tt '/'}, followed by one or more element names. Each element name
      contains characters in the set {\tt [a-zA-Z0-9\_]}, and must have at
      least one character.
\end{itemize}

Element names are separated by {\tt '/'}, and the path may not end in
{\tt '/'} unless it is the root path.

<<DBus/Types.hs>>=
mkObjectPath :: String -> Maybe ObjectPath
mkObjectPath s = parseMaybe path' s where
	c = P.oneOf $ ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_"
	path = P.char '/' >>= P.optional . P.sepBy (P.many1 c) . P.char
	path' = path >> P.eof >> return (ObjectPath s)

mkObjectPath' :: String -> ObjectPath
mkObjectPath' = mkUnsafe "object path" mkObjectPath

<<exports>>=
, ObjectPath
, mkObjectPath
, mkObjectPath'
, strObjectPath

@ \subsection{Names}

Various aspects of DBus require the use of specially-formatted strings,
called ``names''. All names are limited to 255 characters, and use subsets
of ASCII.

Since all names have basically the same structure (a {\tt newtype}
declaration and some helper functions), I define a macro to automate
the definitions.

<<DBus/Types.hs>>=
#define NAME_TYPE(TYPE, NAME) \
	newtype TYPE = TYPE String \
		deriving (Show, Eq, Ord); \
		                          \
	instance Variable TYPE where \
		{ toVariant = toVariant . str##TYPE \
		; fromVariant = (mk##TYPE =<<) . fromVariant }; \
		                                                \
	instance Atomic TYPE where \
		{ toAtom = toAtom . str##TYPE \
		; fromAtom = (mk##TYPE =<<) . fromAtom }; \
		                                          \
	str##TYPE :: TYPE -> String; \
	str##TYPE (TYPE x) = x; \
	                        \
	mk##TYPE##' :: String -> TYPE; \
	mk##TYPE##' = mkUnsafe NAME mk##TYPE

@ \subsubsection{Bus names}

TODO: describe format of bus names

<<DBus/Types.hs>>=
NAME_TYPE(BusName, "bus name")

mkBusName :: String -> Maybe BusName
mkBusName s = checkLength 255 s >>= parseMaybe parser where
	c = ['a'..'z'] ++ ['A'..'Z'] ++ "_-"
	c' = c ++ ['0'..'9']
	parser = (unique <|> wellKnown) >> P.eof >> return (BusName s)
	unique = P.char ':' >> elems c'
	wellKnown = elems c
	elems start = elem' start >> P.many1 (P.char '.' >> elem' start)
	elem' start = P.oneOf start >> P.many (P.oneOf c')

<<exports>>=
, BusName
, mkBusName
, mkBusName'
, strBusName

@ \subsubsection{Interface names}

An interface name consists of two or more {\tt '.'}-separated elements. Each
element constists of characters from the set {\tt [a-zA-Z0-9\_]}, may not
start with a digit, and must have at least one character.

<<DBus/Types.hs>>=
NAME_TYPE(InterfaceName, "interface name")

mkInterfaceName :: String -> Maybe InterfaceName
mkInterfaceName s = checkLength 255 s >>= parseMaybe parser where
	c = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
	c' = c ++ ['0'..'9']
	element = P.oneOf c >> P.many (P.oneOf c')
	name = element >> P.many1 (P.char '.' >> element)
	parser = name >> P.eof >> return (InterfaceName s)

<<exports>>=
, InterfaceName
, mkInterfaceName
, mkInterfaceName'
, strInterfaceName

@ \subsubsection{Error names}

Error names have the same format as interface names, so the parser logic
can just be re-purposed.

<<DBus/Types.hs>>=
NAME_TYPE(ErrorName, "error name")

mkErrorName :: String -> Maybe ErrorName
mkErrorName = fmap (ErrorName . strInterfaceName) . mkInterfaceName

<<exports>>=
, ErrorName
, mkErrorName
, mkErrorName'
, strErrorName

@ \subsubsection{Member names}

TODO: describe format of member names

<<DBus/Types.hs>>=
NAME_TYPE(MemberName, "member name")

mkMemberName :: String -> Maybe MemberName
mkMemberName s = checkLength 255 s >>= parseMaybe parser where
	c = ['a'..'z'] ++ ['A'..'Z'] ++ "_"
	c' = c ++ ['0'..'9']
	name = P.oneOf c >> P.many (P.oneOf c')
	parser = name >> P.eof >> return (MemberName s)

<<exports>>=
, MemberName
, mkMemberName
, mkMemberName'
, strMemberName
